(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{329:function(t,_,s){"use strict";s.r(_);var e=s(12),a=Object(e.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"stm32"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#stm32"}},[t._v("#")]),t._v(" STM32")]),t._v(" "),_("h2",{attrs:{id:"开发环境"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#开发环境"}},[t._v("#")]),t._v(" 开发环境")]),t._v(" "),_("h3",{attrs:{id:"使用-keil-开发"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#使用-keil-开发"}},[t._v("#")]),t._v(" 使用 Keil 开发")]),t._v(" "),_("p",[t._v("Keil MDK 是开发 STM32 单片机最常用的工具链")]),t._v(" "),_("p",[t._v("可以跟着视频里的操作配置 Keil 的开发环境，\n推荐视频："),_("a",{attrs:{href:"https://www.bilibili.com/video/BV1th411z7sn/?p=3&share_source=copy_web&vd_source=f593b5be3aefe519cea20d1a5086e5bb",target:"_blank",rel:"noopener noreferrer"}},[t._v("STM32入门教程-江协科技"),_("OutboundLink")],1)]),t._v(" "),_("p",[t._v("要使用 Keil 开发单片机，首先要在 keil 里安装对应微控制器型号的 DFP 包，可以在 Keil 中在线安装，也可以手动导入已经下载的 DFP 包。\nDFP 包提供了微控制器的重要资源信息，有了它 keil 才能开发对应的微控制器，例如 "),_("code",[t._v("Keil.STM32F1xx_DFP.2.2.0.pack")]),t._v(" 就是STM32F1系列的开发资源包")]),t._v(" "),_("p",[_("strong",[t._v("下载DFP包")])]),t._v(" "),_("ol",[_("li",[t._v("打开 Keil，点击菜单栏中的 "),_("code",[t._v("Pack Installer")]),t._v(" 图标。")]),t._v(" "),_("li",[t._v("在 "),_("code",[t._v("Pack Installer")]),t._v(' 窗口中，浏览或搜索 "STM32F1"。')]),t._v(" "),_("li",[t._v("找到 "),_("code",[t._v("Keil.STM32F1xx_DFP")]),t._v(" ，点击 "),_("code",[t._v("Install")]),t._v(" 即可自动下载和安装。")])]),t._v(" "),_("p",[_("strong",[t._v("新建工程")])]),t._v(" "),_("ol",[_("li",[t._v("建立工程文件夹，Keil中新建工程，选择型号")]),t._v(" "),_("li",[t._v("工程文件夹里建立Start、Library、User等文件夹，复制固件库里面的文件到工程文件夹")]),t._v(" "),_("li",[t._v("工程里对应建立Start、Library、User等同名称的分组，然后将文件夹内的文件添加到工程分组里")]),t._v(" "),_("li",[_("code",[t._v("Options for Target -> C/C++ -> Include Paths")]),t._v(" 内声明所有包含头文件的文件夹")]),t._v(" "),_("li",[_("code",[t._v("Options for Target -> C/C++ -> Define")]),t._v(" 内定义 "),_("code",[t._v("USE_STDPERIPH_DRIVER")])]),t._v(" "),_("li",[_("code",[t._v("Options for Target -> Debug")]),t._v("，下拉列表选择对应调试器，"),_("code",[t._v("Options for Target -> Debug -> Settings -> Flash Download")]),t._v(" 里勾选 "),_("code",[t._v("Reset and Run")])])]),t._v(" "),_("p",[t._v("当我们要将程序在单片机中烧录或调试时就需要将电脑和单片机通过 ST-LINK 或 J-Link 连接，如果电脑没有安装过相关驱动则需要安装驱动后才能使用，")]),t._v(" "),_("p",[_("strong",[t._v("安装驱动")]),t._v("：")]),t._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"https://www.st.com.cn/zh/development-tools/stsw-link009.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("ST-LINK驱动下载"),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"https://www.segger.com/downloads/jlink/",target:"_blank",rel:"noopener noreferrer"}},[t._v("J-Link驱动下载"),_("OutboundLink")],1)])]),t._v(" "),_("p",[t._v("ST-Link 与 STM32 通过 4 根线连接，具体引脚对应关系如下：")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("ST-Link引脚")]),t._v(" "),_("th",[t._v("STM32引脚")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("3.3V")]),t._v(" "),_("td",[t._v("3.3V")])]),t._v(" "),_("tr",[_("td",[t._v("GND")]),t._v(" "),_("td",[t._v("GND")])]),t._v(" "),_("tr",[_("td",[t._v("SWDIO")]),t._v(" "),_("td",[t._v("PA13（JTMS/SWDIO）")])]),t._v(" "),_("tr",[_("td",[t._v("SWCLK")]),t._v(" "),_("td",[t._v("PA14（JTCK/SWCLK）")])])])]),t._v(" "),_("p",[t._v("部分型号可能需要额外连接 "),_("code",[t._v("NRST")]),t._v("（复位引脚）以实现硬件复位功能。")]),t._v(" "),_("p",[_("strong",[t._v("STM32工程架构")])]),t._v(" "),_("p",[_("img",{attrs:{src:"/img/STM32/STM32%E5%B7%A5%E7%A8%8B%E6%9E%B6%E6%9E%84.svg",alt:"STM32工程架构"}})]),t._v(" "),_("details",{staticClass:"custom-block details"},[_("summary",[t._v("项目文件结构")]),t._v(" "),_("div",{staticClass:"language-txt extra-class"},[_("pre",{pre:!0,attrs:{class:"language-txt"}},[_("code",[t._v(".\n├─User                         // 用户文件\n|  ├─main.c                    // 主函数文件\n|  ├─stm32f10x_conf.h          // 库函数配置\n|  ├─stm32f10x_it.c            // 中断处理函数\n|  └stm32f10x_it.h\n├─Start                        \n|   ├─core_cm3.c               // 内核寄存器描述文件\n|   ├─core_cm3.h\n|   ├─startup_stm32f10x_md.s   // 启动文件\n|   ├─stm32f10x.h              // 外设寄存器描述\n|   ├─system_stm32f10x.c       // 定义Systemlnit\n|   └system_stm32f10x.h\n└─Library                      // 库函数\n    ├─misc.c\n    ├─misc.h\n    ├─stm32f10x_adc.c\n    ├─stm32f10x_adc.h\n    ├─stm32f10x_bkp.c\n    ├─stm32f10x_bkp.h\n    ├─stm32f10x_can.c\n    ├─stm32f10x_can.h\n    ├─stm32f10x_cec.c\n    ├─stm32f10x_cec.h\n    ├─stm32f10x_crc.c\n    ├─stm32f10x_crc.h\n    ├─stm32f10x_dac.c\n    ├─stm32f10x_dac.h\n    ├─stm32f10x_dbgmcu.c\n    ├─stm32f10x_dbgmcu.h\n    ├─stm32f10x_dma.c\n    ├─stm32f10x_dma.h\n    ├─stm32f10x_exti.c\n    ├─stm32f10x_exti.h\n    ├─stm32f10x_flash.c\n    ├─stm32f10x_flash.h\n    ├─stm32f10x_fsmc.c\n    ├─stm32f10x_fsmc.h\n    ├─stm32f10x_gpio.c\n    ├─stm32f10x_gpio.h\n    ├─stm32f10x_i2c.c\n    ├─stm32f10x_i2c.h\n    ├─stm32f10x_iwdg.c\n    ├─stm32f10x_iwdg.h\n    ├─stm32f10x_pwr.c\n    ├─stm32f10x_pwr.h\n    ├─stm32f10x_rcc.c\n    ├─stm32f10x_rcc.h\n    ├─stm32f10x_rtc.c\n    ├─stm32f10x_rtc.h\n    ├─stm32f10x_sdio.c\n    ├─stm32f10x_sdio.h\n    ├─stm32f10x_spi.c\n    ├─stm32f10x_spi.h\n    ├─stm32f10x_tim.c\n    ├─stm32f10x_tim.h\n    ├─stm32f10x_usart.c\n    ├─stm32f10x_usart.h\n    ├─stm32f10x_wwdg.c\n    └stm32f10x_wwdg.h\n")])])])]),t._v(" "),_("p",[t._v("以上工程架构中的文件需要在官网下载："),_("a",{attrs:{href:"https://www.st.com.cn/zh/embedded-software/stsw-stm32054.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("STM32F10x标准外设库"),_("OutboundLink")],1),t._v("，\n如果需要其他更多型号芯片的可以访问"),_("a",{attrs:{href:"https://www.st.com.cn/zh/embedded-software/stm32-standard-peripheral-libraries.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("STM32标准外设软件库"),_("OutboundLink")],1),t._v("进行下载")]),t._v(" "),_("p",[_("strong",[t._v("启动文件选择对照表")])]),t._v(" "),_("p",[t._v("启动文件为 "),_("code",[t._v(".s")]),t._v(" 格式的汇编文件，是芯片上电或复位后执行的​​第一段代码​​，负责完成硬件初始化、软件环境准备等关键任务，为后续用户程序（如main函数）的正常运行奠定基础")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("缩写")]),t._v(" "),_("th",[t._v("说明")]),t._v(" "),_("th",[t._v("Flash容量")]),t._v(" "),_("th",[t._v("型号")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("LD_VL")]),t._v(" "),_("td",[t._v("小容量产品超值系列")]),t._v(" "),_("td",[t._v("16-32K")]),t._v(" "),_("td",[t._v("STM32F100")])]),t._v(" "),_("tr",[_("td",[t._v("MD_VL")]),t._v(" "),_("td",[t._v("中容量产品超值系列")]),t._v(" "),_("td",[t._v("64-128K")]),t._v(" "),_("td",[t._v("STM32F100")])]),t._v(" "),_("tr",[_("td",[t._v("HD_VL")]),t._v(" "),_("td",[t._v("大容量产品超值系列")]),t._v(" "),_("td",[t._v("256-512K")]),t._v(" "),_("td",[t._v("STM32F100")])]),t._v(" "),_("tr",[_("td",[t._v("LD")]),t._v(" "),_("td",[t._v("小容量产品")]),t._v(" "),_("td",[t._v("16-32K")]),t._v(" "),_("td",[t._v("STM32F101/102/103")])]),t._v(" "),_("tr",[_("td",[t._v("MD")]),t._v(" "),_("td",[t._v("中容量产品")]),t._v(" "),_("td",[t._v("64-128K")]),t._v(" "),_("td",[t._v("STM32F101/102/103")])]),t._v(" "),_("tr",[_("td",[t._v("HD")]),t._v(" "),_("td",[t._v("大容量产品")]),t._v(" "),_("td",[t._v("256-512K")]),t._v(" "),_("td",[t._v("STM32F101/102/103")])]),t._v(" "),_("tr",[_("td",[t._v("XL")]),t._v(" "),_("td",[t._v("加大容量产品")]),t._v(" "),_("td",[t._v("大于512K")]),t._v(" "),_("td",[t._v("STM32F101/102/103")])])])]),t._v(" "),_("p",[t._v("以下是 stm32f10x 所有的启动文件，根据芯片型号和对应的需求选择相应的启动文件，这里我选择了 "),_("code",[t._v("startup_stm32f10x_md.s")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("div",{staticClass:"highlight-lines"},[_("br"),_("br"),_("br"),_("br"),_("br"),_("div",{staticClass:"highlighted"},[t._v(" ")]),_("br"),_("br"),_("br")]),_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("startup_stm32f10x_cl.s\nstartup_stm32f10x_hd.s\nstartup_stm32f10x_hd_vl.s\nstartup_stm32f10x_ld.s\nstartup_stm32f10x_ld_vl.s\nstartup_stm32f10x_md.s\nstartup_stm32f10x_md_vl.s\nstartup_stm32f10x_xl.s\n")])])]),_("div",{staticClass:"custom-block warning"},[_("p",{staticClass:"custom-block-title"},[t._v("注意")]),t._v(" "),_("p",[t._v("ARM Compiler 5（AC5） 使用 ARMCC； 而 ARM Compiler 6（AC6） 使用 armclang(基于 LLVM/Clang) 作为工具链，不再支持 ARMCC，Keil MDK V5.36 之后版本默认集成 AC6。")]),t._v(" "),_("p",[t._v("用 AC6 开发 AC5 会出现兼容性问题，如果要使用 ARMCC 推荐安装 Keil MDK V5.36 之前的版本")])]),t._v(" "),_("h3",{attrs:{id:"使用-vscode-开发"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#使用-vscode-开发"}},[t._v("#")]),t._v(" 使用 VScode 开发")]),t._v(" "),_("p",[t._v("在 VScode 中开发 STM32 需要安装插件 "),_("code",[t._v("Embedded IDE")]),t._v(" 或 "),_("code",[t._v("STM32Cube for Visual Studio Code")]),t._v("，"),_("code",[t._v("Embedded IDE")]),t._v(" 可以将 Keil 中创建的项目导入在 VScode 中开发；"),_("code",[t._v("STM32Cube for Visual Studio Code")]),t._v(" 是官方推出的插件，通过将 STM32CubeMX 生成的 CMake 项目导入到 VSCode 进行开发。")]),t._v(" "),_("ul",[_("li",[t._v("如果选择使用 "),_("code",[t._v("Embedded IDE")]),t._v(" 推荐文章："),_("a",{attrs:{href:"https://blog.csdn.net/m0_74858601/article/details/139050698?fromshare=blogdetail&sharetype=blogdetail&sharerId=139050698&sharerefer=PC&sharesource=Yoseya2410&sharefrom=from_link",target:"_blank",rel:"noopener noreferrer"}},[t._v("VSCode+EIDE开发STM32"),_("OutboundLink")],1)]),t._v(" "),_("li",[t._v("如果选择使用 "),_("code",[t._v("STM32Cube for Visual Studio Code")]),t._v(" 推荐视频："),_("a",{attrs:{href:"https://www.bilibili.com/video/BV1QfbpzGENy/?share_source=copy_web&vd_source=f593b5be3aefe519cea20d1a5086e5bb",target:"_blank",rel:"noopener noreferrer"}},[t._v("手把手教你用VSCode开发STM32"),_("OutboundLink")],1)])]),t._v(" "),_("h4",{attrs:{id:"在使用-embedded-ide-时遇到的问题及解决办法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#在使用-embedded-ide-时遇到的问题及解决办法"}},[t._v("#")]),t._v(" 在使用 Embedded IDE 时遇到的问题及解决办法")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("问题1")]),t._v("：编译出错显示 "),_("code",[t._v('#error directive: "Please select first the target STM32F10x device used in your application (in stm32f10x.h file)" armcc(35)')])])]),t._v(" "),_("p",[_("strong",[t._v("解决办法")]),t._v("：点击 "),_("code",[t._v("芯片支持包(Chip Support Package)")]),t._v(" -> "),_("code",[t._v("From Repo")]),t._v(" -> 安装对应型号的"),_("a",{attrs:{href:"https://em-ide.com/zh-cn/docs/modules/chip_pkg#%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E6%94%AF%E6%8C%81%E5%8C%85",target:"_blank",rel:"noopener noreferrer"}},[t._v("芯片支持包"),_("OutboundLink")],1),t._v("并选择对应的芯片类型")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("问题2")]),t._v("：烧录程序时找不到烧录文件 "),_("code",[t._v("Error: File does not exist: Project.hex")])])]),t._v(" "),_("p",[_("strong",[t._v("解决办法")]),t._v("：打开 "),_("code",[t._v("构建配置")]),t._v(" -> "),_("code",[t._v("构建器选项")]),t._v(" -> "),_("code",[t._v("链接器")]),t._v(" -> 取消勾选 "),_("code",[t._v("不生成 Hex/Bin/S19 等二进制文件")]),t._v(" 并保存。推荐文章："),_("a",{attrs:{href:"https://blog.csdn.net/qq_64777806/article/details/140127251?fromshare=blogdetail&sharetype=blogdetail&sharerId=140127251&sharerefer=PC&sharesource=Yoseya2410&sharefrom=from_link",target:"_blank",rel:"noopener noreferrer"}},[t._v("解决：VScode插件EmbeddedIDE插件烧录时找不到hex文件"),_("OutboundLink")],1)]),t._v(" "),_("p",[t._v("其他有关 Embedded IDE 的问题可以查阅"),_("a",{attrs:{href:"https://em-ide.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("EIDE插件官网"),_("OutboundLink")],1)]),t._v(" "),_("h3",{attrs:{id:"使用-arduino-ide-开发"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#使用-arduino-ide-开发"}},[t._v("#")]),t._v(" 使用 Arduino IDE 开发")]),t._v(" "),_("h4",{attrs:{id:"在-arduino-中开发-stm32f1xx-系列-mcu"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#在-arduino-中开发-stm32f1xx-系列-mcu"}},[t._v("#")]),t._v(" 在 Arduino 中开发 STM32F1XX 系列 MCU")]),t._v(" "),_("p",[t._v("在"),_("code",[t._v("文件 —> 首选项 —> 其他开发板管理器地址")]),t._v("中填写链接")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("https://dan.drown.org/stm32duino/package_STM32duino_index.json\n")])])]),_("p",[t._v("然后在 "),_("code",[t._v("开发板管理器")]),t._v(" 中搜索 "),_("code",[t._v("STM32F1XX/GD32F1XX boards")]),t._v(" 并安装")]),t._v(" "),_("h4",{attrs:{id:"在-arduino-中开发-stm32-全系列-mcu"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#在-arduino-中开发-stm32-全系列-mcu"}},[t._v("#")]),t._v(" 在 Arduino 中开发 STM32 全系列 MCU")]),t._v(" "),_("p",[t._v("可以尝试使用这个链接")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("https://raw.githubusercontent.com/stm32duino/BoardManagerFiles/main/package_stmicroelectronics_index.json\n")])])]),_("p",[t._v("在 "),_("code",[t._v("文件 —> 首选项 —> 其他开发板管理器地址")]),t._v(" 输入链接后可以在 "),_("code",[t._v("开发板管理器")]),t._v(" 中搜索到 "),_("code",[t._v("STM32 MCU based boards")]),t._v(" 和 "),_("code",[t._v("STM8 MCU based boards")])]),t._v(" "),_("p",[t._v("该项目的文档可以在这里"),_("a",{attrs:{href:"https://github.com/stm32duino/Arduino_Core_STM32?tab=readme-ov-file",target:"_blank",rel:"noopener noreferrer"}},[t._v("查看"),_("OutboundLink")],1)]),t._v(" "),_("h2",{attrs:{id:"stm32开发示例"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#stm32开发示例"}},[t._v("#")]),t._v(" STM32开发示例")]),t._v(" "),_("p",[t._v("开发STM32单片机主要有以下几种方式：")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("寄存器开发")]),t._v("：直接操作STM32的硬件寄存器，通过地址映射和指针访问外设寄存器。代码执行效率高，深入硬件底层工作原理。")]),t._v(" "),_("li",[_("strong",[t._v("标准库函数开发")]),t._v("：使用ST提供的标准外设库，通过封装好的API函数操作外设。开发效率较高，简化了寄存器配置。")]),t._v(" "),_("li",[_("strong",[t._v("HAL库开发")]),t._v("：基于硬件抽象层（Hardware Abstraction Layer）库，提供更高层次的API，支持跨芯片移植。使用图形化工具 STM32CubeMX 自动生成初始化代码，同一代码可适配不同STM32型号。")])]),t._v(" "),_("h4",{attrs:{id:"使用寄存器开发"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#使用寄存器开发"}},[t._v("#")]),t._v(" 使用寄存器开发")]),t._v(" "),_("p",[t._v("以 STM32F103C8T6 芯片为例，简单开发一个程序点亮开发板上的 LED 灯 (引脚为"),_("code",[t._v("C13")]),t._v(")，将代码写入 "),_("code",[t._v("main.c")]),t._v(" 文件中")]),t._v(" "),_("div",{staticClass:"language-c extra-class"},[_("pre",{pre:!0,attrs:{class:"language-c"}},[_("code",[_("span",{pre:!0,attrs:{class:"token macro property"}},[_("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),_("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token string"}},[t._v('"stm32f10x.h"')])]),t._v("\n\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tRCC"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("APB2ENR "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("0x00000010")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 使能GPIOC的时钟，使GPIOC可以正常工作")]),t._v("\n\tGPIOC"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("CRH "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("0x00300000")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 配置PC13引脚为推挽输出模式")]),t._v("\n\tGPIOC"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("ODR "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("0x00002000")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将PC13引脚设置为高电平")]),t._v("\n\t"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 通过无限循环保持程序持续运行")]),t._v("\n\t"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\n\t"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),_("p",[t._v("PC13是指GPIOC的13号引脚（P：表示Port(端口)；C：表示GPIO端口）")])]),t._v(" "),_("p",[t._v("STM32 是​32位​的微控制器，绝大多数外设的控制/状态寄存器​​,内核的通用寄存器都是32位的。")]),t._v(" "),_("p",[t._v("我们需要通过控制 GPIO 输出高低电平来实现 LED 灯的亮灭，而 GPIO 都是高速总线 APB2 的外设，所以我们要先打开 GPIO 的时钟，让 GPIO 端口可以正常工作。")]),t._v(" "),_("p",[t._v("以下是APB2外设时钟使能寄存器的结构：")]),t._v(" "),_("p",[_("img",{attrs:{src:"/img/STM32/%E5%A4%96%E8%AE%BE%E6%97%B6%E9%92%9F%E4%BD%BF%E8%83%BD%E5%AF%84%E5%AD%98%E5%99%A8.svg",alt:"外设时钟使能寄存器"}})]),t._v(" "),_("details",{staticClass:"custom-block details"},[_("summary",[t._v("APB2外设时钟使能寄存器(RCC_APB2ENR)说明")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("位")]),t._v(" "),_("th",[t._v("功能描述")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("31:15")]),t._v(" "),_("td",[t._v("保留, 始终读为0")])]),t._v(" "),_("tr",[_("td",[t._v("14")]),t._v(" "),_("td",[_("strong",[t._v("USART1EN")]),t._v(": USART1时钟使能。由软件置"),_("code",[t._v("1")]),t._v("或清"),_("code",[t._v("0")]),t._v("。"),_("br"),_("code",[t._v("0")]),t._v(": USART1时钟关闭;"),_("br"),t._v(" "),_("code",[t._v("1")]),t._v(": USART1时钟开启")])]),t._v(" "),_("tr",[_("td",[t._v("13")]),t._v(" "),_("td",[t._v("保留, 始终读为0")])]),t._v(" "),_("tr",[_("td",[t._v("12")]),t._v(" "),_("td",[_("strong",[t._v("SPI1EN")]),t._v(": SPI1时钟使能。由软件置"),_("code",[t._v("1")]),t._v("或清"),_("code",[t._v("0")]),t._v("。"),_("br"),_("code",[t._v("0")]),t._v(": SPI1时钟关闭;"),_("br"),t._v(" "),_("code",[t._v("1")]),t._v(": SPI1时钟开启")])]),t._v(" "),_("tr",[_("td",[t._v("11")]),t._v(" "),_("td",[_("strong",[t._v("TIM1EN")]),t._v(": TIM1定时器时钟使能。由软件置"),_("code",[t._v("1")]),t._v("或清"),_("code",[t._v("0")]),t._v("。"),_("br"),_("code",[t._v("0")]),t._v(": TIM1定时器时钟关闭;"),_("br"),t._v(" "),_("code",[t._v("1")]),t._v(": TIM1定时器时钟开启")])]),t._v(" "),_("tr",[_("td",[t._v("10")]),t._v(" "),_("td",[_("strong",[t._v("ADC2EN")]),t._v(": ADC2接口时钟使能。由软件置"),_("code",[t._v("1")]),t._v("或清"),_("code",[t._v("0")]),t._v("。"),_("br"),_("code",[t._v("0")]),t._v(": ADC2接口时钟关闭;"),_("br"),t._v(" "),_("code",[t._v("1")]),t._v(": ADC2接口时钟开启")])]),t._v(" "),_("tr",[_("td",[t._v("9")]),t._v(" "),_("td",[_("strong",[t._v("ADC1EN")]),t._v(": ADC1接口时钟使能。由软件置"),_("code",[t._v("1")]),t._v("或清"),_("code",[t._v("0")]),t._v("。"),_("br"),_("code",[t._v("0")]),t._v(": ADC1接口时钟关闭;"),_("br"),t._v(" "),_("code",[t._v("1")]),t._v(": ADC1接口时钟开启")])]),t._v(" "),_("tr",[_("td",[t._v("8:7")]),t._v(" "),_("td",[t._v("保留, 始终读为0")])]),t._v(" "),_("tr",[_("td",[t._v("6")]),t._v(" "),_("td",[_("strong",[t._v("IOPEEN")]),t._v(": IO端口E时钟使能。由软件置"),_("code",[t._v("1")]),t._v("或清"),_("code",[t._v("0")]),t._v("。"),_("br"),_("code",[t._v("0")]),t._v(": IO端口E时钟关闭;"),_("br"),t._v(" "),_("code",[t._v("1")]),t._v(": IO端口E时钟开启")])]),t._v(" "),_("tr",[_("td",[t._v("5")]),t._v(" "),_("td",[_("strong",[t._v("IOPDEN")]),t._v(": IO端口D时钟使能。由软件置"),_("code",[t._v("1")]),t._v("或清"),_("code",[t._v("0")]),t._v("。"),_("br"),_("code",[t._v("0")]),t._v(": IO端口D时钟关闭;"),_("br"),t._v(" "),_("code",[t._v("1")]),t._v(": IO端口D时钟开启")])]),t._v(" "),_("tr",[_("td",[t._v("4")]),t._v(" "),_("td",[_("strong",[t._v("IOPCEN")]),t._v(": IO端口C时钟使能。由软件置"),_("code",[t._v("1")]),t._v("或清"),_("code",[t._v("0")]),t._v("。"),_("br"),_("code",[t._v("0")]),t._v(": IO端口C时钟关闭;"),_("br"),t._v(" "),_("code",[t._v("1")]),t._v(": IO端口C时钟开启")])]),t._v(" "),_("tr",[_("td",[t._v("3")]),t._v(" "),_("td",[_("strong",[t._v("IOPBEN")]),t._v(": IO端口B时钟使能。由软件置"),_("code",[t._v("1")]),t._v("或清"),_("code",[t._v("0")]),t._v("。"),_("br"),_("code",[t._v("0")]),t._v(": IO端口B时钟关闭;"),_("br"),t._v(" "),_("code",[t._v("1")]),t._v(": IO端口B时钟开启")])]),t._v(" "),_("tr",[_("td",[t._v("2")]),t._v(" "),_("td",[_("strong",[t._v("IOPAEN")]),t._v(": IO端口A时钟使能。由软件置"),_("code",[t._v("1")]),t._v("或清"),_("code",[t._v("0")]),t._v("。"),_("br"),_("code",[t._v("0")]),t._v(": IO端口A时钟关闭;"),_("br"),t._v(" "),_("code",[t._v("1")]),t._v(": IO端口A时钟开启")])]),t._v(" "),_("tr",[_("td",[t._v("1")]),t._v(" "),_("td",[t._v("保留, 始终读为0")])]),t._v(" "),_("tr",[_("td",[t._v("0")]),t._v(" "),_("td",[_("strong",[t._v("AFIOEN")]),t._v(": 辅助功能IO时钟使能。由软件置"),_("code",[t._v("1")]),t._v("或清"),_("code",[t._v("0")]),t._v("。"),_("br"),_("code",[t._v("0")]),t._v(": 辅助功能IO时钟关闭;"),_("br"),t._v(" "),_("code",[t._v("1")]),t._v(": 辅助功能IO时钟开启")])])])])]),t._v(" "),_("p",[t._v("要点亮的 LED 灯的引脚是 "),_("code",[t._v("PC13")]),t._v("，属于 "),_("code",[t._v("GPIOC")]),t._v(" 端口，所以我们先要打开 "),_("code",[t._v("GPIOC")]),t._v(" 的时钟，该时钟由第 4 位 "),_("code",[t._v("IOPCEN")]),t._v(" 控制，将这该位设为 "),_("code",[t._v("1")]),t._v(" 表示开启 "),_("code",[t._v("GPIOC")]),t._v(" 时钟。\n这时寄存器 "),_("code",[t._v("APB2ENR")]),t._v(" 的值为：")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("0000 0000 0000 0000\n0000 0000 0001 0000\n")])])]),_("p",[t._v("每 4 位一组，转换成对应的十六进制为 "),_("code",[t._v("0x00000010")])]),t._v(" "),_("p",[t._v("使用代码打开 "),_("code",[t._v("GPIOC")]),t._v(" 的时钟")]),t._v(" "),_("div",{staticClass:"language-C extra-class"},[_("pre",{pre:!0,attrs:{class:"language-c"}},[_("code",[t._v("RCC"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("APB2ENR "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("0x00000010")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),_("p",[t._v("然后配置 "),_("code",[t._v("PC13")]),t._v(" 端口的输入输出模式，以下是端口配置高寄存器的结构说明，要控制 "),_("code",[t._v("GPIOC_Pin_13")]),t._v(" 端口需要 "),_("code",[t._v("CNF13")]),t._v(" 和 "),_("code",[t._v("MODE13")]),t._v(" 两个位段（两个连续的二进制位（Bit）组成）")]),t._v(" "),_("p",[_("img",{attrs:{src:"/img/STM32/%E7%AB%AF%E5%8F%A3%E9%85%8D%E7%BD%AE%E9%AB%98%E5%AF%84%E5%AD%98%E5%99%A8.png",alt:"端口配置高寄存器(GPIOx_CRH)"}})]),t._v(" "),_("details",{staticClass:"custom-block details"},[_("summary",[t._v("端口配置低寄存器(GPIOx_CRL)")]),t._v(" "),_("p",[_("img",{attrs:{src:"/img/STM32/%E7%AB%AF%E5%8F%A3%E9%85%8D%E7%BD%AE%E4%BD%8E%E5%AF%84%E5%AD%98%E5%99%A8.png",alt:"端口配置低寄存器(GPIOx_CRL)"}})])]),t._v(" "),_("p",[t._v("将 "),_("code",[t._v("GPIOC_Pin_13")]),t._v(" 端口设置为推挽输出模式，最大速度为 50 MHz，"),_("code",[t._v("CNF13")]),t._v(" 和 "),_("code",[t._v("MODE13")]),t._v(" 的值分别为 "),_("code",[t._v("00")]),t._v(" 和 "),_("code",[t._v("11")])]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("位段")]),t._v(" "),_("th",[t._v("编号")]),t._v(" "),_("th",[t._v("说明")]),t._v(" "),_("th",[t._v("配置选项")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[_("code",[t._v("CNF13")])]),t._v(" "),_("td",[t._v("23:22")]),t._v(" "),_("td",[t._v("端口13配置位"),_("br"),t._v("用于设置端口13的具体输入/输出配置"),_("br"),t._v("其具体含义取决于MODE13的设置")]),t._v(" "),_("td",[_("strong",[t._v("当 MODE13 设置为输入模式 (00) 时:")]),_("br"),t._v("  00: 模拟输入模式 (用于ADC等)"),_("br"),t._v("  01: 浮空输入模式 (电平由外部决定)"),_("br"),t._v(" 10: 上拉/下拉输入模式"),_("br"),t._v(" 11: 保留"),_("br"),_("br"),_("strong",[t._v("当 MODE13 设置为输出模式 (01,10,11) 时:")]),_("br"),t._v(" 00: 通用输出推挽模式"),_("br"),t._v(" 01: 通用输出开漏模式"),_("br"),t._v(" 10: 复用功能推挽输出 (由外设控制)"),_("br"),t._v(" 11: 复用功能开漏输出 (由外设控制)")])]),t._v(" "),_("tr",[_("td",[_("code",[t._v("MODE13")])]),t._v(" "),_("td",[t._v("21:20")]),t._v(" "),_("td",[t._v("端口13模式位"),_("br"),t._v("用于设置端口13的基本工作模式和输出速度")]),t._v(" "),_("td",[t._v("00: 输入模式 (复位后的状态)"),_("br"),t._v("01: 输出模式，最大速度 10 MHz"),_("br"),t._v("10: 输出模式，最大速度 2 MHz"),_("br"),t._v("11: 输出模式，最大速度 50 MHz")])])])]),t._v(" "),_("p",[t._v("寄存器 "),_("code",[t._v("GPIOx_CRH")]),t._v(" 的值为")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("0000 0000 0011 0000\n0000 0000 0000 0000\n")])])]),_("p",[t._v("转换为十六进制为 "),_("code",[t._v("0x00300000")]),t._v("，用代码设置 GPIOC 端口的输出模式")]),t._v(" "),_("div",{staticClass:"language-c extra-class"},[_("pre",{pre:!0,attrs:{class:"language-c"}},[_("code",[t._v("GPIOC"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("CRH "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("0x00300000")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),_("p",[t._v("现在就可以通过 GPIOC 端口输出数据了，输出数据需要使用端口输出数据寄存器("),_("code",[t._v("GPIOx_ODR")]),t._v(")，点亮LED灯需要将 13 引脚设置为高电平，"),_("code",[t._v("ODR13")]),t._v(" 控制该引脚，值为 1 是高电平 0 是低电平")]),t._v(" "),_("p",[_("img",{attrs:{src:"/img/STM32/%E7%AB%AF%E5%8F%A3%E8%BE%93%E5%87%BA%E5%AF%84%E5%AD%98%E5%99%A8.png",alt:"端口输出数据寄存器(GPIOx_ODR)"}})]),t._v(" "),_("details",{staticClass:"custom-block details"},[_("summary",[t._v("端口输入寄存器")]),t._v(" "),_("p",[_("img",{attrs:{src:"/img/STM32/%E7%AB%AF%E5%8F%A3%E8%BE%93%E5%85%A5%E5%AF%84%E5%AD%98%E5%99%A8.png",alt:"端口输入数据寄存器(GPIOx_IDR)"}})])]),t._v(" "),_("p",[t._v("我们将 13 引脚设置为高电平，寄存器 "),_("code",[t._v("GPIOx_ODR")]),t._v(" 的值为")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("0000 0000 0000 0000\n0010 0000 0000 0000\n")])])]),_("p",[t._v("转换成十六进制为 "),_("code",[t._v("0x00002000")]),t._v("，用代码设置 GPIOC 端口的输出，13 引脚为高电平，其他 GPIOC 端口的引脚为低电平")]),t._v(" "),_("div",{staticClass:"language-c extra-class"},[_("pre",{pre:!0,attrs:{class:"language-c"}},[_("code",[t._v("GPIOC"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("ODR "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("0x00002000")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("注意")]),t._v(" "),_("p",[_("code",[t._v("GPIOC->ODR = 0x00002000;")]),t._v(" 这种方法会改变寄存器中的所有位，会影响该端口其他引脚的原有配置；如果只设置 13 引脚，不影响其他引脚，可以使用位运算操作引脚")]),t._v(" "),_("div",{staticClass:"language-c extra-class"},[_("pre",{pre:!0,attrs:{class:"language-c"}},[_("code",[t._v("GPIOC"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("ODR "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("13")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),_("p",[_("code",[t._v("1")]),t._v(" 是二进制的 "),_("code",[t._v("0000000000000001")]),t._v("，"),_("code",[t._v("<< 13")]),t._v(" 表示向左移动 13 位结果是二进制  "),_("code",[t._v("10000000000000")]),t._v(" 就是在保持其他位不变的同时将 1 向左移动 13 位，这样"),_("code",[t._v("ODR13")]),t._v(" 变成了 "),_("code",[t._v("1")])])]),t._v(" "),_("h4",{attrs:{id:"使用标准库函数开发"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#使用标准库函数开发"}},[t._v("#")]),t._v(" 使用标准库函数开发")]),t._v(" "),_("p",[t._v("以 STM32F103C8T6 芯片为例，简单开发一个程序点亮开发板上的 LED 灯 (引脚为"),_("code",[t._v("C13")]),t._v(")，将代码写入 "),_("code",[t._v("main.c")]),t._v(" 文件中")]),t._v(" "),_("div",{staticClass:"language-c extra-class"},[_("pre",{pre:!0,attrs:{class:"language-c"}},[_("code",[_("span",{pre:!0,attrs:{class:"token macro property"}},[_("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),_("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token string"}},[t._v('"stm32f10x.h"')]),t._v("  "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 导入STM32F10x型号的头文件，该文件定义了所有外设寄存器和相关函数")])]),t._v("\n\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 该函数为程序的入口")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 启用GPIOC端口的时钟，使GPIOC可以正常工作")]),t._v("\n\t"),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("RCC_APB2PeriphClockCmd")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("RCC_APB2Periph_GPIOC"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("ENABLE"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 定义一个GPIO结构体变量 GPIO_InitStructure")]),t._v("\n\tGPIO_InitTypeDef GPIO_InitStructure"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 配置GPIO端口")]),t._v("\n\tGPIO_InitStructure"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("GPIO_Mode "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" GPIO_Mode_Out_PP"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将该变量的GPIO模式设置为推挽输出模式")]),t._v("\n\tGPIO_InitStructure"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("GPIO_Pin "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" GPIO_Pin_13"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将该变量的引脚为13")]),t._v("\n\tGPIO_InitStructure"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("GPIO_Speed "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" GPIO_Speed_50MHz"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将该变量的GPIO输出速度设置为50MHz")]),t._v("\n\n  "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 调用GPIO初始化函数，将上述配置应用到GPIOC端口")]),t._v("\n\t"),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("GPIO_Init")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("GPIOC"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("GPIO_InitStructure"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 控制GPIO端口输入输出")]),t._v("\n\t"),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("GPIO_SetBits")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("GPIOC"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("GPIO_Pin_13"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//设置GPIOC的第13引脚为高电平（3.3V）")]),t._v("\n\t"),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("GPIO_ResetBits")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("GPIOC"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("GPIO_Pin_13"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//设置GPIOC的第13引脚为低电平（0V），用于点亮LED")]),t._v("\n\n  "),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 无限循环，确保程序持续运行")]),t._v("\n\t"),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\t"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\n\t"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),_("ul",[_("li",[_("p",[_("strong",[_("code",[t._v("RCC_APB2PeriphClockCmd")]),t._v(" 是 RCC 时钟控制函数")]),t._v("：")]),t._v(" "),_("ul",[_("li",[_("code",[t._v("RCC_APB2Periph_GPIOC")]),t._v(" 表示GPIOC端口")]),t._v(" "),_("li",[_("code",[t._v("ENABLE")]),t._v(" 表示使能时钟")])])]),t._v(" "),_("li",[_("p",[_("strong",[_("code",[t._v("GPIO_InitTypeDef")]),t._v(" 是一个结构体类型名，它是STM32标准外设库中预定义的数据类型，专门用于GPIO外设的初始化配置，该结构体有以下成员")]),t._v("：")]),t._v(" "),_("ul",[_("li",[_("code",[t._v("GPIO_Mode")]),t._v(": 配置GPIO的工作模式（输入/输出模式）")]),t._v(" "),_("li",[_("code",[t._v("GPIO_Speed")]),t._v(": 配置GPIO的输出速度")]),t._v(" "),_("li",[_("code",[t._v("GPIO_Pin")]),t._v(": 指定要配置的GPIO引脚")])])]),t._v(" "),_("li",[_("p",[_("strong",[_("code",[t._v("GPIO_Init")]),t._v(" 用于初始化用于初始化GPIO，使GPIO端口根据配置的方式工作，该函数有两个参数")]),t._v("：")]),t._v(" "),_("ul",[_("li",[_("code",[t._v("GPIOx")]),t._v(": 指定要配置的GPIO端口，例如GPIOA、GPIOB、GPIOC等")]),t._v(" "),_("li",[_("code",[t._v("GPIO_InitStruct")]),t._v(": 指向包含GPIO配置信息的结构体的指针，例如 "),_("code",[t._v("&GPIO_InitStructure")])])])]),t._v(" "),_("li",[_("p",[_("strong",[_("code",[t._v("GPIO_SetBits")]),t._v(": 将指定的GPIO引脚设置为高电平，该函数有两个参数")]),t._v("：")]),t._v(" "),_("ul",[_("li",[_("code",[t._v("GPIOx")]),t._v(": GPIO端口（如GPIOA、GPIOB、GPIOC等）")]),t._v(" "),_("li",[_("code",[t._v("GPIO_Pin")]),t._v(": 要设置为高电平的引脚（可以是单个或多个引脚）")])])]),t._v(" "),_("li",[_("p",[_("strong",[_("code",[t._v("GPIO_ResetBits")]),t._v(": 将指定的GPIO引脚设置为低电平，该函数有两个参数")]),t._v("：")]),t._v(" "),_("ul",[_("li",[_("code",[t._v("GPIOx")]),t._v(": GPIO端口（如GPIOA、GPIOB、GPIOC等）")]),t._v(" "),_("li",[_("code",[t._v("GPIO_Pin")]),t._v(": 要设置为高电平的引脚（可以是单个或多个引脚）")])])])]),t._v(" "),_("div",{staticClass:"custom-block warning"},[_("p",{staticClass:"custom-block-title"},[t._v("注意")]),t._v(" "),_("ol",[_("li",[t._v("在STM32单片机开发中，​​主函数 "),_("code",[t._v("main()")]),t._v(" 中通常需要包含一个无限循环，如 "),_("code",[t._v("while(1)")]),t._v("​​，否则会导致程序异常或功能失效。循环内可以是空的，但不能没有这个循环。")]),t._v(" "),_("li",[t._v("代码中的结构体变量是可以任意命名的， 可以把 "),_("code",[t._v("GPIO_InitStructure")]),t._v(" 换成其他名字")]),t._v(" "),_("li",[t._v("STM32具有多个GPIO端口，例如GPIOA、GPIOB、GPIOC等，这是由芯片架构设计决定的")]),t._v(" "),_("li",[_("strong",[t._v("什么是推挽输出模式？")])])]),t._v(" "),_("p",[t._v("推挽输出模式（Push-Pull Output）是GPIO的一种能够主动输出高电平和低电平输出模式")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("    VCC\n     |\n   [开关1]\n     |\n     |---- 输出引脚\n     |\n   [开关2]\n     |\n    GND\n")])])]),_("ul",[_("li",[t._v("输出高电平时，"),_("code",[t._v("开关1")]),t._v(" 导通，"),_("code",[t._v("开关2")]),t._v(" 截止，输出引脚连接到VCC")]),t._v(" "),_("li",[t._v("输出低电平时，"),_("code",[t._v("开关2")]),t._v(" 导通，"),_("code",[t._v("开关1")]),t._v(" 截止，输出引脚连接到GND")])])]),t._v(" "),_("h2",{attrs:{id:"gpio-的输入输出"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#gpio-的输入输出"}},[t._v("#")]),t._v(" GPIO 的输入输出")]),t._v(" "),_("p",[t._v("GPIO 是通用输入输出接口，常用于与外部设备通信、控制外部设备、读取外设信号。")]),t._v(" "),_("ul",[_("li",[t._v("引脚电平一般为 0 ~ 3.3V 部分引脚支持 5V")]),t._v(" "),_("li",[t._v("可以控制端口输出高低电平控制外部设备、模拟通信协议输出时序信号，或者读取端口高低电平输入、模拟通信协议接收数据")])]),t._v(" "),_("p",[t._v("所有的 GPIO 端口都与 ABP2 总线连接，有 GPIOA、GPIOB、GPIOC 等多个端口（不同型号的芯片端口数量不同），每个 GPIO 端口都有 16 个引脚，从 0 开始排序，例如 GPIOA 的第 "),_("code",[t._v("0")]),t._v(" 号引脚为 "),_("code",[t._v("PA0")]),t._v("，GPIOC 的第 "),_("code",[t._v("13")]),t._v(" 号引脚为 "),_("code",[t._v("PC3")])]),t._v(" "),_("h3",{attrs:{id:"gpio基本结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#gpio基本结构"}},[t._v("#")]),t._v(" GPIO基本结构")]),t._v(" "),_("p",[_("img",{attrs:{src:"/img/STM32/GPIO%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.svg",alt:"GPIO基本结构"}})]),t._v(" "),_("p",[t._v("每个 GPIO 端口模块中都有寄存器、驱动器等，内核可以通过APB2总线对寄存器进行读取，每一个引脚都对应着寄存器的一个为，一个端口有 16 个引脚，而 STM32 是一个 32 位的单片机，寄存器的低16位连接对应的引脚，而高16位没有被用到；驱动器用来增加信号的驱动能力")]),t._v(" "),_("h3",{attrs:{id:"stm32系统结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#stm32系统结构"}},[t._v("#")]),t._v(" STM32系统结构")]),t._v(" "),_("p",[t._v("这张图以 "),_("code",[t._v("STM32F103C8T6")]),t._v(" 微控制器的系统结构为例，看图中的 APB1、APB2 可以很直观看到两条总线所连接的引脚，它们都是用来连接外设的")]),t._v(" "),_("p",[_("img",{attrs:{src:"/img/STM32/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.png",alt:"系统结构"}})]),t._v(" "),_("h3",{attrs:{id:"gpio端口位的基本结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#gpio端口位的基本结构"}},[t._v("#")]),t._v(" GPIO端口位的基本结构")]),t._v(" "),_("p",[t._v("这就是 GPIO 中位的基本结构，整个结构可以分为两部分：上面控制输出；下面控制输入。\n其中左边部分是寄存器，中间是驱动器，右边是保护电路。")]),t._v(" "),_("p",[_("img",{attrs:{src:"/img/STM32/GPIO%E4%BD%8D%E7%BB%93%E6%9E%84.png",alt:"GPIO端口位的基本结构 "}})]),t._v(" "),_("h3",{attrs:{id:"输入模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#输入模式"}},[t._v("#")]),t._v(" 输入模式")]),t._v(" "),_("p",[t._v("图中 "),_("code",[t._v("TTL Schmitt trigger")]),t._v(" 的右边有两个电阻，上拉电阻至 "),_("code",[t._v("VDD")]),t._v("，下拉电阻至 "),_("code",[t._v("VSS")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("    VDD\n     |\n   [开关1]\n     |\n     |---- 输出引脚\n     |\n   [开关2]\n     |\n    VSS\n")])])]),_("ul",[_("li",[_("strong",[t._v("上拉输入模式")]),t._v("：上拉电阻，导通【开关1】 断开【开关2】")]),t._v(" "),_("li",[_("strong",[t._v("下拉输入模式")]),t._v("：下拉电阻，导通【开关2】 断开【开关1】")]),t._v(" "),_("li",[_("strong",[t._v("浮空输入模式")]),t._v("：两个开关都断开（电平状态不确定，容易受干扰）")]),t._v(" "),_("li",[_("strong",[t._v("模拟输入模式")]),t._v("：GPIO的输入输出都断开，引脚直接连接到内部的模数转换器（ADC）")])]),t._v(" "),_("p",[t._v("当外部没有信号输入时，上拉输入模式默认为高电平，下拉输入模式默认为低电平")]),t._v(" "),_("h4",{attrs:{id:"施密特触发器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#施密特触发器"}},[t._v("#")]),t._v(" 施密特触发器")]),t._v(" "),_("p",[t._v("施密特触发器（TTL Schmitt trigger）用于将输入的电压进行整形（整理波形），当电压大于某一阈值输出为高电平，当电压小于某一阈值时电压为为低电平。在传递信号时不可避免的会出现信号中的噪声和毛刺，该触发器可以将不规则的输入信号转换为标准的方波信号")]),t._v(" "),_("p",[t._v("经过施密特触发器整形后数据会存储在输入数据寄存器（"),_("code",[t._v("GPIOx_IDR")]),t._v("）中，使用程序读取该寄存器输入的每一位数据就可以知道端口的输入电平了")]),t._v(" "),_("h3",{attrs:{id:"输出模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#输出模式"}},[t._v("#")]),t._v(" 输出模式")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("    VDD\n     |\n   [P-MOS]\n     |\n     |---- 输出引脚\n     |\n   [N-MOS]\n     |\n    VSS\n")])])]),_("ul",[_("li",[_("strong",[t._v("推挽输出模式")]),t._v("：是GPIO的一种能够主动输出高电平和低电平输出模式\n"),_("ul",[_("li",[t._v("输出高电平时，"),_("code",[t._v("开关1")]),t._v(" 导通，"),_("code",[t._v("开关2")]),t._v(" 截止，输出引脚连接到 "),_("code",[t._v("VDD")])]),t._v(" "),_("li",[t._v("输出低电平时，"),_("code",[t._v("开关2")]),t._v(" 导通，"),_("code",[t._v("开关1")]),t._v(" 截止，输出引脚连接到 "),_("code",[t._v("VSS")])])])]),t._v(" "),_("li",[_("strong",[t._v("开漏输出模式")]),t._v(": "),_("code",[t._v("P-MOS")]),t._v(" 不生效，只使用 "),_("code",[t._v("N-MOS")]),t._v(" "),_("ul",[_("li",[t._v("输出低电平时，"),_("code",[t._v("N-MOS")]),t._v("管导通，输出引脚直接连接到 "),_("code",[t._v("GND")])]),t._v(" "),_("li",[t._v("输出高电平时，"),_("code",[t._v("N-MOS")]),t._v("管截止（断开），输出引脚呈高阻态（悬空）")])])])]),t._v(" "),_("p",[t._v("在输入模式时，"),_("code",[t._v("N-MOS")]),t._v(" 和 "),_("code",[t._v("P-MOS")]),t._v(" 都是断开的，输出模式为关闭状态；在输出模式时，GPIO 输出可以正常使用。输出模式时可以输入，但输入模式时不能输出。")]),t._v(" "),_("p",[_("strong",[t._v("复用功能输出模式")]),t._v("：这个模式下输出不与输出数据寄存器连接，引脚的控制权转移到了片上外设")]),t._v(" "),_("ul",[_("li",[t._v("复用功能推挽输出：由外设控制的推挽输出模式")]),t._v(" "),_("li",[t._v("复用功能开漏输出：由外设控制的开漏输出模式")])]),t._v(" "),_("h3",{attrs:{id:"位设置-清除寄存器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#位设置-清除寄存器"}},[t._v("#")]),t._v(" 位设置/清除寄存器")]),t._v(" "),_("p",[t._v("该寄存器可以操作输出数据寄存器的某一位，而不影响其他位。输出数据寄存器控制同时控制16个端口，寄存器只能整体读写，如果要单独控制某一个端口时有两种办法：")]),t._v(" "),_("ol",[_("li",[t._v("先读出寄存器数据，然后通过位运算更改其中的某一位，最后再将更改后的方式写回去")])]),t._v(" "),_("div",{staticClass:"language-c extra-class"},[_("pre",{pre:!0,attrs:{class:"language-c"}},[_("code",[_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 只将PC13设置为高电平")]),t._v("\nGPIOC"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("ODR "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("13")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 只将PC13设置为低电平")]),t._v("\nGPIOC"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("ODR "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("13")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n")])])]),_("ol",{attrs:{start:"2"}},[_("li",[t._v("通过位设置寄存器（"),_("code",[t._v("GPIOx_BSRR")]),t._v("）和位清除寄存器（"),_("code",[t._v("GPIOx_BRR")]),t._v("）。如果要将输出数据寄存器（"),_("code",[t._v("GPIOx_IDR")]),t._v("）的某一位置为 "),_("code",[t._v("1")]),t._v(" 时，在位设置寄存器（"),_("code",[t._v("GPIOx_BSRR")]),t._v("）对应的那一位置为 "),_("code",[t._v("1")]),t._v(" ，其他位为 "),_("code",[t._v("0")]),t._v("，内部电路会按照位设置寄存器（"),_("code",[t._v("GPIOx_BSRR")]),t._v("）中的值自动将输出数据寄存器（"),_("code",[t._v("GPIOx_IDR")]),t._v("）对应的位置为 1，而剩下写 0 的位置保持不变")])]),t._v(" "),_("div",{staticClass:"language-c extra-class"},[_("pre",{pre:!0,attrs:{class:"language-c"}},[_("code",[_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 使用BSRR寄存器设置PC13为高电平")]),t._v("\nGPIOC"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("BSRR "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("13")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),_("p",[t._v("如果要将输出数据寄存器（"),_("code",[t._v("GPIOx_IDR")]),t._v("）的某一位置为 "),_("code",[t._v("0")]),t._v(" 时，在位清除寄存器（"),_("code",[t._v("GPIOx_BSRR")]),t._v("）对应的那一位置为 "),_("code",[t._v("1")]),t._v(" ，其他位为 "),_("code",[t._v("0")]),t._v("，内部电路就会自动将输出数据寄存器（"),_("code",[t._v("GPIOx_IDR")]),t._v("）中对应的那一位清零")]),t._v(" "),_("div",{staticClass:"language-c extra-class"},[_("pre",{pre:!0,attrs:{class:"language-c"}},[_("code",[_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//使用BSRR寄存器设置PC13为低电平")]),t._v("\nGPIOC"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("BSRR "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("13")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("16")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 使用BRR寄存器设置PC13为低电平")]),t._v("\nGPIOC"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("BRR "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[t._v("13")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n")])])]),_("p",[t._v("端口位设置/清除寄存器("),_("code",[t._v("GPIOx_BSRR")]),t._v(") 既可以设置也可以清除，高 16 位用于位清除，低 16 位用于位设置")]),t._v(" "),_("p",[_("img",{attrs:{src:"/img/STM32/%E7%AB%AF%E5%8F%A3%E4%BD%8D%E8%AE%BE%E7%BD%AE%E6%B8%85%E9%99%A4%E5%AF%84%E5%AD%98%E5%99%A8.png",alt:"端口位设置/清除寄存器"}})]),t._v(" "),_("p",[t._v("端口位清除寄存器("),_("code",[t._v("GPIOx_BRR")]),t._v(") 只能用于清除，高 16 位用于位保留，低 16 位用于位清除")]),t._v(" "),_("p",[_("img",{attrs:{src:"/img/STM32/%E7%AB%AF%E5%8F%A3%E4%BD%8D%E6%B8%85%E9%99%A4%E5%AF%84%E5%AD%98%E5%99%A8.png",alt:"端口位清除寄存器"}})]),t._v(" "),_("h2",{attrs:{id:"问题解决"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#问题解决"}},[t._v("#")]),t._v(" 问题解决")]),t._v(" "),_("h3",{attrs:{id:"old-st-link-firmware-detected-do-you-want-to-upgrade-it"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#old-st-link-firmware-detected-do-you-want-to-upgrade-it"}},[t._v("#")]),t._v(" Old ST-LINK firmware detected.do you want to upgrade it?")]),t._v(" "),_("p",[t._v("这是由于 ST-link 固件版本过旧所导致的，可以通过升级固件解决此问题。")]),t._v(" "),_("p",[t._v("推荐两篇文章，文章中详细说明了解决的具体步骤：")]),t._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"https://shequ.stmicroelectronics.cn/thread-634144-1-1.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("【经验分享】STM32 ST-LINK固件升级"),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"https://dingdong.blog.csdn.net/article/details/82778978?fromshare=blogdetail&sharetype=blogdetail&sharerId=82778978&sharerefer=PC&sharesource=Yoseya2410&sharefrom=from_link",target:"_blank",rel:"noopener noreferrer"}},[t._v("Old ST-LINK firmware detected.do you want to upgrade it？已解决，stlink升级"),_("OutboundLink")],1)])]),t._v(" "),_("h3",{attrs:{id:"使用keil5编译程序-代码正确-编译报错"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#使用keil5编译程序-代码正确-编译报错"}},[t._v("#")]),t._v(" 使用Keil5编译程序，代码正确，编译报错")]),t._v(" "),_("p",[_("strong",[t._v("报错代码")]),t._v("：")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v('CORE/core_cm3.c(445): error: non-ASM statement in naked function is not supported\n  uint32_t result=0;\n  ^\nCORE/core_cm3.c(442): note: attribute is here\nuint32_t __get_PSP(void) __attribute__( ( naked ) );\n                                          ^\nCORE/core_cm3.c(465): error: parameter references not allowed in naked functions\n                  "BX  lr     \\n\\t" : : "r" (topOfProcStack) );\n                                             ^\nCORE/core_cm3.c(461): note: attribute is here\nvoid __set_PSP(uint32_t topOfProcStack) __attribute__( ( naked ) );\n                                                         ^\nCORE/core_cm3.c(479): error: non-ASM statement in naked function is not supported\n  uint32_t result=0;\n  ^\nCORE/core_cm3.c(476): note: attribute is here\nuint32_t __get_MSP(void) __attribute__( ( naked ) );\n                                          ^\nCORE/core_cm3.c(499): error: parameter references not allowed in naked functions\n                  "BX  lr     \\n\\t" : : "r" (topOfMainStack) );\n                                             ^\nCORE/core_cm3.c(495): note: attribute is here\nvoid __set_MSP(uint32_t topOfMainStack) __attribute__( ( naked ) );\n                                                         ^\n')])])]),_("p",[_("strong",[t._v("问题分析")]),t._v("： 这是由于编译器版本过高导致的，AC5 的项目在使用 AC6 编译时会出现兼容性问题")]),t._v(" "),_("p",[_("strong",[t._v("解决办法")]),t._v("：在 "),_("code",[t._v("Options for Target")]),t._v(" 中修改编译器为 "),_("code",[t._v("Use default compiler version5")]),t._v("。")]),t._v(" "),_("p",[t._v("推荐帖子："),_("a",{attrs:{href:"https://ask.csdn.net/questions/7628895",target:"_blank",rel:"noopener noreferrer"}},[t._v("STM32使用Keil5编译程序出错"),_("OutboundLink")],1)])])}),[],!1,null,null,null);_.default=a.exports}}]);