(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{338:function(t,v,_){"use strict";_.r(v);var s=_(12),r=Object(s.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"计算机组成原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#计算机组成原理"}},[t._v("#")]),t._v(" 计算机组成原理")]),t._v(" "),v("p",[t._v("计算机组成原理是一门研究计算机硬件系统的基本组成和工作原理的课程。主要学习计算机系统的总体结构，硬件与软件的关系，计算机中数据的表示方法，计算机运算原理，深入理解CPU的结构和工作原理，包括指令集架构、流水线技术等，学习存储系统，输入输出设备工作原理及与主机的接口技术，研究计算机内部用于各部件之间通信的总线系统和数据的并行处理等")]),t._v(" "),v("h2",{attrs:{id:"计算机基本结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#计算机基本结构"}},[t._v("#")]),t._v(" 计算机基本结构")]),t._v(" "),v("h3",{attrs:{id:"冯诺伊曼结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#冯诺伊曼结构"}},[t._v("#")]),t._v(" 冯诺伊曼结构")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("控制计算机的程序")]),t._v("应该"),v("strong",[t._v("存放在存储器中")]),t._v("，而不是由开关连线实现，开关连线会降低计算机的运行效率")]),t._v(" "),v("li",[v("strong",[t._v("计算机")]),t._v("应该"),v("strong",[t._v("采用二进制")]),t._v("而不是十进制，十进制的方式会导致计算机内部结构变得非常复杂")]),t._v(" "),v("li",[t._v("计算机的内部结构由"),v("strong",[t._v("运算器")]),t._v("，"),v("strong",[t._v("控制器")]),t._v("，"),v("strong",[t._v("储存器")]),t._v("，"),v("strong",[t._v("输入设备")]),t._v("，"),v("strong",[t._v("输出设备")]),t._v("这五个部分组成")]),t._v(" "),v("li",[v("strong",[t._v("数据")]),t._v("和"),v("strong",[t._v("程序")]),t._v("均以"),v("strong",[t._v("二进制")]),t._v("的形式"),v("strong",[t._v("不区别")]),t._v("的存放在储存器中，存放的位置由存储器地址（内存地址）指定")]),t._v(" "),v("li",[t._v("每个内存地址都对应着一个储存单元，数据存在存储单元中")]),t._v(" "),v("li",[t._v("计算机工作时能够"),v("strong",[t._v("自动")]),t._v("从储存器中读取指令并执行")]),t._v(" "),v("li",[t._v("指令由操作码和地址码构成，操作码表示计算机要做操作，例如指出寻址(地址)方式，定义参加运算的数据类型，定义参加运算的数据的长度")])]),t._v(" "),v("h3",{attrs:{id:"计算机的五大组成部分"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#计算机的五大组成部分"}},[t._v("#")]),t._v(" 计算机的五大组成部分")]),t._v(" "),v("ul",[v("li",[t._v("运算器 "),v("strong",[t._v("CA")]),t._v(" central arithmetical")]),t._v(" "),v("li",[t._v("控制器 "),v("strong",[t._v("CC")]),t._v(" central control")]),t._v(" "),v("li",[t._v("存储器 "),v("strong",[t._v("M")]),t._v(" memory")]),t._v(" "),v("li",[t._v("输入设备 "),v("strong",[t._v("I")]),t._v(" inpit")]),t._v(" "),v("li",[t._v("输出设备 "),v("strong",[t._v("O")]),t._v(" output")])]),t._v(" "),v("p",[v("img",{attrs:{src:"/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84%E5%9B%BE.svg",alt:"冯诺依曼结构图"}})]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("CPU和存储器之间通过总线连接")]),t._v("，总线可以细化为"),v("strong",[t._v("控制总线")]),t._v("，"),v("strong",[t._v("地址总线")]),t._v("，"),v("strong",[t._v("数据总线")])])]),t._v(" "),v("p",[v("strong",[t._v("随机存储器（RAM）")]),t._v("： 可以进行读取和写入，但断电后内容就会丢失。"),v("strong",[t._v("对应冯诺依曼结构中的储存器")]),t._v("一般称之为内存或主存储器")]),t._v(" "),v("p",[v("strong",[t._v("移位寄存器（I/O）")]),t._v("：用来进行输入和输出")]),t._v(" "),v("p",[v("strong",[t._v("微处理器(CPU)")]),t._v("：一片或几片大规模集成电路组成的中央处理器，它用于读取指令、执行指令，以及与外界存储器和逻辑部件交换信息等操作，是微型计算机的运算控制部分。它可与存储器和外围电路芯片组成微型计算机。"),v("strong",[t._v("对应冯诺依曼结构中的控制器和运算器")])]),t._v(" "),v("p",[v("strong",[t._v("只读存储器（ROM）")]),t._v("：用来存放一些指令，只能读取不能写入(第一次写入后就不能修改)，断电以后内容不会丢失，"),v("strong",[t._v("不包括在冯诺依曼结构中")])]),t._v(" "),v("h3",{attrs:{id:"计算机运行过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#计算机运行过程"}},[t._v("#")]),t._v(" 计算机运行过程")]),t._v(" "),v("p",[v("img",{attrs:{src:"/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.svg",alt:"计算机运行过程"}})]),t._v(" "),v("p",[t._v("首先，"),v("strong",[t._v("程序和数据")]),t._v("通过"),v("strong",[t._v("输入设备")]),t._v("进入"),v("strong",[t._v("存储器")]),t._v("，然后"),v("strong",[t._v("控制器")]),t._v("发出"),v("strong",[t._v("地址")]),t._v("给"),v("strong",[t._v("存储器")]),t._v("，并从"),v("strong",[t._v("存储器")]),t._v("中获得程序中对应的"),v("strong",[t._v("指令")]),t._v("，这时控制器会发出命令给"),v("strong",[t._v("运算器")]),t._v("，指挥"),v("strong",[t._v("运算器")]),t._v("对"),v("strong",[t._v("存储器")]),t._v("中的"),v("strong",[t._v("数据")]),t._v("进行相应的"),v("strong",[t._v("运算")]),t._v("，"),v("strong",[t._v("运算器")]),t._v("会"),v("strong",[t._v("返回")]),t._v("一些运算"),v("strong",[t._v("状态")]),t._v("告诉"),v("strong",[t._v("控制器")]),t._v("，例如运算是否成功，还会把运算后的"),v("strong",[t._v("结果")]),t._v("存放在"),v("strong",[t._v("存储器")]),t._v("中，最后通过"),v("strong",[t._v("输出设备")]),t._v("输出结果。输出设备可以是显示屏，音响，或者一些存储设备等")]),t._v(" "),v("h3",{attrs:{id:"存储器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#存储器"}},[t._v("#")]),t._v(" 存储器")]),t._v(" "),v("ul",[v("li",[t._v("设计计算机时确定存储器的编址方式")]),t._v(" "),v("li",[t._v("每个存储单元存放"),v("strong",[t._v("8位")]),t._v("二进制数")]),t._v(" "),v("li",[t._v("每个存储单元的地址是"),v("strong",[t._v("唯一的")]),t._v("，不同存储单元的地址"),v("strong",[t._v("互不相同")])]),t._v(" "),v("li",[v("strong",[t._v("地址总线")]),t._v("用来访问（读取/写入）计算机"),v("strong",[t._v("内存地址")]),t._v("，地址总线宽度决定了CPU可以访问的物理地址空间，简单地说就是CPU到底能够使用多大容量的内存。如果地址总线宽度为"),v("strong",[t._v("n")]),t._v("，则CPU能管理的存储单元是"),v("mjx-container",{staticClass:"MathJax",staticStyle:{direction:"ltr",position:"relative"},attrs:{jax:"SVG"}},[v("svg",{staticStyle:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"0"},attrs:{xmlns:"http://www.w3.org/2000/svg",width:"2.279ex",height:"1.528ex",role:"img",focusable:"false",viewBox:"0 -675.5 1007.3 675.5","aria-hidden":"true"}},[v("g",{attrs:{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"scale(1,-1)"}},[v("g",{attrs:{"data-mml-node":"math"}},[v("g",{attrs:{"data-mml-node":"msup"}},[v("g",{attrs:{"data-mml-node":"mn"}},[v("path",{staticStyle:{"stroke-width":"3"},attrs:{"data-c":"32",d:"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"}})]),v("g",{attrs:{"data-mml-node":"mi",transform:"translate(533,363) scale(0.707)"}},[v("path",{staticStyle:{"stroke-width":"3"},attrs:{"data-c":"1D45B",d:"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"}})])])])])]),v("mjx-assistive-mml",{staticStyle:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"},attrs:{unselectable:"on",display:"inline"}},[v("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[v("msup",[v("mn",[t._v("2")]),v("mi",[t._v("n")])],1)],1)],1)],1),t._v("个，假设地址总线宽度为32位，那么CPU可以管理的存储单元为"),v("mjx-container",{staticClass:"MathJax",staticStyle:{direction:"ltr",position:"relative"},attrs:{jax:"SVG"}},[v("svg",{staticStyle:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"0"},attrs:{xmlns:"http://www.w3.org/2000/svg",width:"2.919ex",height:"1.887ex",role:"img",focusable:"false",viewBox:"0 -833.9 1290.1 833.9","aria-hidden":"true"}},[v("g",{attrs:{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"scale(1,-1)"}},[v("g",{attrs:{"data-mml-node":"math"}},[v("g",{attrs:{"data-mml-node":"msup"}},[v("g",{attrs:{"data-mml-node":"mn"}},[v("path",{staticStyle:{"stroke-width":"3"},attrs:{"data-c":"32",d:"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"}})]),v("g",{attrs:{"data-mml-node":"TeXAtom",transform:"translate(533,363) scale(0.707)","data-mjx-texclass":"ORD"}},[v("g",{attrs:{"data-mml-node":"mn"}},[v("path",{staticStyle:{"stroke-width":"3"},attrs:{"data-c":"33",d:"M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"}}),v("path",{staticStyle:{"stroke-width":"3"},attrs:{"data-c":"32",d:"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z",transform:"translate(500,0)"}})])])])])])]),v("mjx-assistive-mml",{staticStyle:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"},attrs:{unselectable:"on",display:"inline"}},[v("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[v("msup",[v("mn",[t._v("2")]),v("mrow",{attrs:{"data-mjx-texclass":"ORD"}},[v("mn",[t._v("32")])],1)],1)],1)],1)],1),t._v("=4GB")],1),t._v(" "),v("li",[v("strong",[t._v("数据总线")]),t._v("传输CPU要读写的"),v("strong",[t._v("数据")]),t._v("，数据总线的宽度一般为"),v("strong",[t._v("存储单元位宽")]),t._v("的"),v("strong",[t._v("整数倍")])]),t._v(" "),v("li",[v("strong",[t._v("控制总线")]),t._v("用于传送控制信号和时序信号，用于接收CPU的读写信号或者反馈传输已经完成的信号")])]),t._v(" "),v("h3",{attrs:{id:"控制器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#控制器"}},[t._v("#")]),t._v(" 控制器")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("指令寄存器(IR)")]),t._v(" 用于存放正在执行或即将执行的指令")]),t._v(" "),v("li",[v("strong",[t._v("程序计数器(PC)")]),t._v(" 用于存放下一条指令的单元地址，具有自动递增的计数功能")]),t._v(" "),v("li",[v("strong",[t._v("存储器地址寄存器(MAR)")]),t._v(" 用于存放CPU访问存储器时正在读写的地址")]),t._v(" "),v("li",[v("strong",[t._v("内存数据寄存器(MDR)")]),t._v(" 用于存放CPU正在读取或写入存储单元的数据")]),t._v(" "),v("li",[v("strong",[t._v("指令译码部件")]),t._v(" 用于对IR中的指令进行译码，以确定IR中存放的是哪一条指令")]),t._v(" "),v("li",[t._v("当确定指令之后，控制电路就可以产生对应的控制信号，控制信号在时许脉冲的同步下控制各个部件的动作")])]),t._v(" "),v("h3",{attrs:{id:"运算器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#运算器"}},[t._v("#")]),t._v(" 运算器")]),t._v(" "),v("ul",[v("li",[t._v("运算器用于完成运算，运算可以分为"),v("strong",[t._v("算数运算")]),t._v("和"),v("strong",[t._v("逻辑运算")])]),t._v(" "),v("li",[t._v("算数运算为"),v("strong",[t._v("加")]),t._v("，"),v("strong",[t._v("减")]),t._v("，"),v("strong",[t._v("乘")]),t._v("，"),v("strong",[t._v("除")]),t._v("等")]),t._v(" "),v("li",[t._v("逻辑运算为"),v("strong",[t._v("或")]),t._v("，"),v("strong",[t._v("与")]),t._v("，"),v("strong",[t._v("非")]),t._v("等")]),t._v(" "),v("li",[v("strong",[t._v("ALU")]),t._v(" 这是运算器的核心部件，用于完成算术运算和逻辑运算")])]),t._v(" "),v("p",[v("img",{attrs:{src:"/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%BF%90%E7%AE%97%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84.svg",alt:"运算器结构"}})]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("X")]),t._v("，"),v("strong",[t._v("Y")]),t._v("，"),v("strong",[t._v("Z")]),t._v("表示用于暂时保存数据的寄存器")]),t._v(" "),v("li",[t._v("图中的ALU有两输入口和一个输出口，如果要进行加法运算，要做运算的两个数分别从A端口和B端口输入，通过ALU运算后将结果输出到Z")]),t._v(" "),v("li",[t._v("在ALU运算时会产生各种状态保存在"),v("strong",[t._v("寄存器F")]),t._v("中，例如，是否为负数，是否进位，是否溢出等")]),t._v(" "),v("li",[t._v("运算器运算的数据是在存储器中读取的，为了提高效率就会设置一个临时存放数据的地方，这就是"),v("strong",[t._v("通用寄存器")])]),t._v(" "),v("li",[t._v("通用寄存器中有n个，通用寄存器中的数据来自于存储器也可以来自于其他通用寄存器或者ALU的输出")]),t._v(" "),v("li",[t._v("可以在两个不同的寄存器间传递数据，也可以在ALU和通用寄存器间传递数据")])]),t._v(" "),v("h3",{attrs:{id:"内部总线"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内部总线"}},[t._v("#")]),t._v(" 内部总线")]),t._v(" "),v("ul",[v("li",[t._v("内部总线用于在CPU各个部件间传递数据，如果CPU中的一个部件要把数据传递给另一个部件时就要通过内部总线")])]),t._v(" "),v("h3",{attrs:{id:"计算机执行指令的过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#计算机执行指令的过程"}},[t._v("#")]),t._v(" 计算机执行指令的过程")]),t._v(" "),v("p",[v("img",{attrs:{src:"/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%89%A7%E8%A1%8C%E6%8C%87%E4%BB%A4%E7%9A%84%E8%BF%87%E7%A8%8B.svg",alt:"计算机执行指令的过程"}})]),t._v(" "),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("取指令：  控制器将指令的地址交给存储器，存储器按照给定的地址读出指令并送回控制器")]),t._v(" "),v("ol",[v("li",[t._v("首先，"),v("strong",[t._v("控制器")]),t._v("发出信号将"),v("strong",[t._v("PC")]),t._v("中预执行的"),v("strong",[t._v("指令地址")]),t._v("通过"),v("strong",[t._v("内部总线")]),t._v("传送到"),v("strong",[t._v("MAR")]),t._v("中")]),t._v(" "),v("li",[v("strong",[t._v("CPU中MAR")]),t._v("通过"),v("strong",[t._v("地址总线")]),t._v("把"),v("strong",[t._v("地址")]),t._v("传送给"),v("strong",[t._v("存储器")]),t._v("，"),v("strong",[t._v("存储器的MAR")]),t._v("就会收到"),v("strong",[t._v("该地址")]),t._v("并保存下来。同时，"),v("strong",[t._v("控制电路")]),t._v("发出控制信号告诉"),v("strong",[t._v("存储器")]),t._v("此次访问要进行读取数据的操作，"),v("strong",[t._v("存储器的控制逻辑")]),t._v("会收到"),v("strong",[t._v("控制总线")]),t._v("传来的信号，得知这次访问要做的操作是读操作。")]),t._v(" "),v("li",[v("strong",[t._v("存储器")]),t._v("通过"),v("strong",[t._v("地址译码器")]),t._v("找到"),v("strong",[t._v("地址")]),t._v("对应的内存空间中存放的"),v("strong",[t._v("内容")])]),t._v(" "),v("li",[t._v("把找到的"),v("strong",[t._v("内容")]),t._v("送到"),v("strong",[t._v("MDR")])]),t._v(" "),v("li",[t._v("这时"),v("strong",[t._v("存储器的控制逻辑")]),t._v("会向"),v("strong",[t._v("CPU")]),t._v("反馈当前传输已经准备好了，同时"),v("strong",[t._v("MDR")]),t._v("的内容通过数据总线传入"),v("strong",[t._v("CPU")]),t._v("，随后"),v("strong",[t._v("CPU")]),t._v("中的"),v("strong",[t._v("控制电路")]),t._v("检测到"),v("strong",[t._v("存储器")]),t._v("传送过来的信号，就知道当前数据总线上已经准备好了数据，因此"),v("strong",[t._v("MDR")]),t._v("就会将当前传输过来的数据保存下来，这时CPU就获得了所要取的指令（现在获得的是指令编码，之后还需要翻译成指令）")]),t._v(" "),v("li",[t._v("把"),v("strong",[t._v("MDR")]),t._v("中的指令传送到"),v("strong",[t._v("IR")]),t._v("中，并把"),v("strong",[t._v("PC")]),t._v("中的地址"),v("strong",[t._v("更新")]),t._v("为下一条指令所对应的"),v("strong",[t._v("地址")])])])]),t._v(" "),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("译码：控制器分析指令的操作性质，并向有关部件发出指令所需的控制信号")]),t._v(" "),v("ol",{attrs:{start:"7"}},[v("li",[v("strong",[t._v("IR")]),t._v("把指令编码送到"),v("strong",[t._v("指令译码")]),t._v("部件中翻译成指令")]),t._v(" "),v("li",[t._v("根据指令，控制电路产生控制信号传送到相关部件中")])])]),t._v(" "),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("执行指令：控制器从通用寄存器中或存储器中取出操作数，并命令运算器对操作数进行指令规定的运算")]),t._v(" "),v("ol",{attrs:{start:"9"}},[v("li",[v("p",[t._v("根据指令，需要取操作数，"),v("strong",[t._v("CPU的MAR")]),t._v("获取操作数的"),v("strong",[t._v("地址")]),t._v("。之后的步骤与取指阶段类似，从存储器中获取的数据保存到"),v("strong",[t._v("CPU的MDR")]),t._v("中")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("控制器")]),t._v("将"),v("strong",[t._v("MDR")]),t._v("中的数据暂存到"),v("strong",[t._v("寄存器Y")]),t._v("中，这时一个操作数已经准备好了。另一个操作数存放在其他的通用寄存器中，把这个操作数暂存在"),v("strong",[t._v("寄存器X")]),t._v("中")])]),t._v(" "),v("li",[v("p",[t._v("在控制电路的控制下"),v("strong",[t._v("ALU")]),t._v("会对"),v("strong",[t._v("寄存器X")]),t._v("和"),v("strong",[t._v("寄存器Y")]),t._v("中的操作数进行运算，计算出的结果存放在"),v("strong",[t._v("寄存器Z")]),t._v("中")])])])]),t._v(" "),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("回写：将运算结果写入到通用寄存器或存储器")]),t._v(" "),v("ol",{attrs:{start:"12"}},[v("li",[t._v("把"),v("strong",[t._v("寄存器Z")]),t._v("中的结果通过"),v("strong",[t._v("内部总线")]),t._v("传送到"),v("strong",[t._v("通用寄存器")]),t._v("中（通用寄存器不是一个寄存器，而是多个寄存器的总称），如果存放的寄存器中有内容，则原来存放的数据会被新的数据覆盖掉")])])]),t._v(" "),v("ul",[v("li",[t._v("指令执行完毕后，获取下一个指令，继续重复这样的步骤")])]),t._v(" "),v("h3",{attrs:{id:"计算机输入与输出"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#计算机输入与输出"}},[t._v("#")]),t._v(" 计算机输入与输出")]),t._v(" "),v("ul",[v("li",[t._v("常见的"),v("strong",[t._v("输出设备")]),t._v("：显示器、打印机、投影仪、绘图仪、喇叭等")]),t._v(" "),v("li",[t._v("常见的"),v("strong",[t._v("输入设备")]),t._v("： 键盘、鼠标、触摸屏 、扫描仪、摄像头、手写板、麦克风等")])]),t._v(" "),v("p",[v("strong",[t._v("在特殊情况下，一个设备既可以做输入设备，也可以做输出设备")]),t._v("。\n例如"),v("strong",[t._v("硬盘")]),t._v("，"),v("strong",[t._v("硬盘")]),t._v("既可以"),v("strong",[t._v("输出数据")]),t._v("，也可以"),v("strong",[t._v("写入数据")]),t._v("，还可以"),v("strong",[t._v("保存数据")]),t._v("。硬盘保存数据的"),v("strong",[t._v("磁片")]),t._v("可以叫做"),v("strong",[t._v("外部记录介质")]),t._v("，而硬盘中的"),v("strong",[t._v("电路和控制芯片")]),t._v("可以认为是"),v("strong",[t._v("输入或输出设备")]),t._v("的一部分")]),t._v(" "),v("p",[v("img",{attrs:{src:"/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%A4%BA%E6%84%8F%E5%9B%BE.svg",alt:"输入输出示意"}})]),t._v(" "),v("p",[v("strong",[t._v("假设CPU和存储器已经开始工作了，现在我们要通过调整这些开关来控制灯泡的亮暗")]),t._v("。我们将"),v("strong",[t._v("输入输出设备")]),t._v("中"),v("strong",[t._v("地址为1111的单元")]),t._v("连接到这些手动"),v("strong",[t._v("开关")]),t._v("。这个单元有8个比特，"),v("strong",[t._v("每个比特连接一个开关")]),t._v("，当开关拨动在"),v("strong",[t._v("上方时")]),t._v("，对应的位"),v("strong",[t._v("为1")]),t._v("，开关在"),v("strong",[t._v("下方时")]),t._v("对应的位"),v("strong",[t._v("为0")]),t._v("，另一个"),v("strong",[t._v("地址为1110")]),t._v("的"),v("strong",[t._v("单位")]),t._v("连接到这"),v("strong",[t._v("8个灯泡")]),t._v("，单位中的"),v("strong",[t._v("每个位")]),t._v("都"),v("strong",[t._v("对应")]),t._v("着"),v("strong",[t._v("一个灯泡")]),t._v("，分别"),v("strong",[t._v("用0和1表示高低电平")]),t._v("，"),v("strong",[t._v("高电平时灯泡亮，低电平时灯泡灭")]),t._v("。\n现在计算机会执行一个指令，这个指令是"),v("strong",[t._v("读取输入设备中地址为1111的数据")]),t._v("（这些手动开关的状态），"),v("strong",[t._v("具体如下：")])]),t._v(" "),v("p",[v("strong",[t._v("输入：")])]),t._v(" "),v("p",[v("strong",[t._v("CPU")]),t._v("先将输入设备(手动开关)的"),v("strong",[t._v("地址")]),t._v("（1111）发送到"),v("strong",[t._v("地址总线上")]),t._v("，总线上的一些电路会识别这个地址，得知这个地址应该发送到输入设备，与此同时"),v("strong",[t._v("CPU")]),t._v("会通过"),v("strong",[t._v("控制总线")]),t._v("向"),v("strong",[t._v("输入设备")]),t._v("发出read信号，告诉"),v("strong",[t._v("输入设备")]),t._v("目前是一个"),v("strong",[t._v("读操作")]),t._v("。这时"),v("strong",[t._v("输入设备")]),t._v("的"),v("strong",[t._v("控制逻辑")]),t._v("和"),v("strong",[t._v("地址译码器")]),t._v("就会从"),v("strong",[t._v("CPU")]),t._v("发送过来的"),v("strong",[t._v("地址")]),t._v("（1111）找到对应单元里的"),v("strong",[t._v("数据")]),t._v("，然后通过"),v("strong",[t._v("数据总线")]),t._v("将数据传回到"),v("strong",[t._v("CPU")]),t._v("，这样就完成了"),v("strong",[t._v("输入信息")]),t._v("的读取工作，（之后CPU可以对这个数据进行运算，处理或保存在存储器中，以便之后使用）")]),t._v(" "),v("p",[v("strong",[t._v("输出：")])]),t._v(" "),v("p",[v("strong",[t._v("CPU")]),t._v("先将输出设备(灯泡)的"),v("strong",[t._v("地址")]),t._v("（1110）发送到"),v("strong",[t._v("地址总线上")]),t._v("，总线上的一些电路会识别这个地址，得知这个地址应该发送到输出设备，与此同时"),v("strong",[t._v("CPU")]),t._v("会通过"),v("strong",[t._v("控制总线")]),t._v("向"),v("strong",[t._v("输出设备")]),t._v("发出write信号，告诉"),v("strong",[t._v("输出设备")]),t._v("目前是一个"),v("strong",[t._v("写操作")]),t._v("。然后通过"),v("strong",[t._v("数据总线")]),t._v("将"),v("strong",[t._v("要输出的数据")]),t._v("传输给"),v("strong",[t._v("输出设备")]),t._v("，这时输出设备就会根据总线传输过来的信息将"),v("strong",[t._v("要输出的数据")]),t._v("写入输出设备地址（1110）所对应的"),v("strong",[t._v("单元")]),t._v("，当数据写入后，根据数据小灯泡会受到高低不同的电压，这时1对应的灯泡亮，0对应的灯泡灭")]),t._v(" "),v("p",[t._v("通过以上方式，我们还可以加入不同的输入输出设备，制造出各种各样的电子产品")]),t._v(" "),v("h2",{attrs:{id:"指令系统"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#指令系统"}},[t._v("#")]),t._v(" 指令系统")]),t._v(" "),v("h3",{attrs:{id:"简单的指令系统"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#简单的指令系统"}},[t._v("#")]),t._v(" 简单的指令系统")]),t._v(" "),v("p",[v("strong",[t._v("现在，我们要设计一个计算机")]),t._v("。一个基本的计算机要有"),v("strong",[t._v("软件")]),t._v("和"),v("strong",[t._v("硬件")]),t._v("两个部分组成。我们要"),v("strong",[t._v("通过计算机的软件来操作计算机的硬件")]),t._v("，这些软件都是用代码编写而成，"),v("strong",[t._v("如何用他们去操作计算机的硬件呢")]),t._v("？这时候我们就需要设计一个计算机"),v("strong",[t._v("软件和硬件交流的“桥梁”")]),t._v(" —— "),v("strong",[t._v("计算机指令系统")])]),t._v(" "),v("p",[t._v("在计算机设计之初，"),v("strong",[t._v("软件和硬件之间就会商量一套指令系统")]),t._v("，以便后续设计出的"),v("strong",[t._v("软件")]),t._v("能够"),v("strong",[t._v("在硬件")]),t._v("上"),v("strong",[t._v("使用")]),t._v("。")]),t._v(" "),v("p",[t._v("根据"),v("RouterLink",{attrs:{to:"/computer/计算机组成原理.html#计算机执行指令的过程"}},[t._v("计算机执行指令的过程")]),t._v("，一个简单的"),v("strong",[t._v("指令系统")]),t._v("通常要有这三种指令")],1),t._v(" "),v("ul",[v("li",[v("strong",[t._v("运算类指令")]),t._v(" 使计算机做运算的指令。例如，加法运算。")]),t._v(" "),v("li",[v("strong",[t._v("传送类指令")]),t._v(" 使存储器和寄存器间传输数据的指令。")]),t._v(" "),v("li",[v("strong",[t._v("转移类指令")]),t._v(" 用于更改取指令的位置。")])]),t._v(" "),v("p",[v("img",{attrs:{src:"/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AE%80%E5%8D%95%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E7%A4%BA%E4%BE%8B.svg",alt:"简单指令系统示例"}})]),t._v(" "),v("p",[t._v("根据需求设计不同的指令，例如我们"),v("strong",[t._v("要做加法运算")]),t._v("，那么"),v("strong",[t._v("就需要一个让两个数相加的指令")]),v("u",[v("strong",[t._v("ADD")])]),t._v("。要做运算就"),v("strong",[t._v("需要进行运算的数据")]),t._v("，但"),v("strong",[t._v("数据和指令存放在存储器中")]),t._v("，这时就"),v("strong",[t._v("需要一个从存储器获取数据的指令")]),v("u",[v("strong",[t._v("LOAD")])]),t._v("。结束运算后数据保存在寄存器中，如果要"),v("strong",[t._v("将运算结果保存在存储器中")]),t._v("，还"),v("strong",[t._v("需要一个将寄存器中的数存入存储器的指令")]),v("u",[v("strong",[t._v("STORE")])]),t._v("。一般情况下，CPU会按照地址从内存中依次读取指令并执行，"),v("strong",[t._v("如果要改变取指令的位置")]),t._v("时就需要再设计一个指令"),v("u",[v("strong",[t._v("JMP")])]),t._v("，该指令可以"),v("strong",[t._v("无条件地转移到指令中所指示的目的地址")]),t._v("。")]),t._v(" "),v("div",{staticClass:"custom-block warning"},[v("p",{staticClass:"custom-block-title"},[t._v("注意")]),t._v(" "),v("p",[v("strong",[t._v("由于指令和数据主要存放在存储器中")]),t._v("，如果把两个存储器中的数直接相加会比较复杂，所以在设计指令系统时，"),v("strong",[t._v("加法指令会将一个寄存器中的数和一个存储器中的数相加，把结果存放在另一个寄存器中")]),t._v("。（寄存器中的数也来自于存储器）")])]),t._v(" "),v("h3",{attrs:{id:"指令的格式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#指令的格式"}},[t._v("#")]),t._v(" 指令的格式")]),t._v(" "),v("ul",[v("li",[t._v("每条指令等长，且均为2个字节")]),t._v(" "),v("li",[t._v("第一个字节的前四位是操作码，最多可以有16条")]),t._v(" "),v("li",[t._v("第一个字节的后四位是寄存器号，最多可以有16个")]),t._v(" "),v("li",[t._v("第二个字节是存储单元的地址，最多可以有256个存储单元")])]),t._v(" "),v("p",[v("img",{attrs:{src:"/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F.svg",alt:"指令的格式"}})]),t._v(" "),v("h3",{attrs:{id:"运算任务示例"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#运算任务示例"}},[t._v("#")]),t._v(" 运算任务示例")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("任务")]),t._v(" "),v("ol",[v("li",[t._v("将"),v("strong",[t._v("存储单元地址")]),t._v("为"),v("u",[v("strong",[t._v("M1")])]),t._v("中的数与"),v("strong",[t._v("存储单元地址")]),t._v("为"),v("u",[v("strong",[t._v("M2")])]),t._v("中的数"),v("strong",[t._v("相加")])]),t._v(" "),v("li",[t._v("把相加后的"),v("strong",[t._v("结果")]),t._v("存入地址为"),v("u",[v("strong",[t._v("M3")])]),t._v("的"),v("strong",[t._v("存储单元")])]),t._v(" "),v("li",[t._v("完成运算后，将程序转向"),v("strong",[t._v("存储单元地址")]),t._v("为"),v("u",[v("strong",[t._v("L")])]),t._v("中的指令继续执行")])])]),t._v(" "),v("p",[v("strong",[t._v("程序设计思路")])]),t._v(" "),v("ol",[v("li",[t._v("将"),v("strong",[t._v("存储单元M1")]),t._v("中的内容送入某个"),v("strong",[t._v("寄存器")]),t._v("("),v("strong",[t._v("R1")]),t._v(")中")]),t._v(" "),v("li",[t._v("将"),v("strong",[t._v("寄存器R1")]),t._v("中的内容与"),v("strong",[t._v("存储单元M2")]),t._v("中的内容"),v("strong",[t._v("相加")]),t._v("，并把运算结果存入"),v("strong",[t._v("寄存器R2")])]),t._v(" "),v("li",[t._v("将"),v("strong",[t._v("寄存器R2")]),t._v("中的内容送入"),v("strong",[t._v("存储单元M3")]),t._v("中")]),t._v(" "),v("li",[t._v("将"),v("strong",[t._v("地址")]),t._v("转向"),v("strong",[t._v("L")]),t._v("，取出下一条指令继续执行")])]),t._v(" "),v("p",[v("strong",[t._v("用指令实现")])]),t._v(" "),v("p",[t._v("以下指令依次对应设计思路中的四个步骤")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("汇编语言               机器语言\nLOAD R1,[5]           0000 0001  00000101\nADD R1,[6]            0001 0001  00000110\nSTORE [7],R2          0010 0010  00000111\nJMP [18]              0011 0000  00010010          \n")])])]),v("p",[v("strong",[t._v("注：M1=5, M2=6, M3=7, L=18")])]),t._v(" "),v("p",[v("img",{attrs:{src:"/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%BF%90%E7%AE%97%E4%BB%BB%E5%8A%A1%E7%A4%BA%E4%BE%8B.svg",alt:"运算任务示例"}})]),t._v(" "),v("div",{staticClass:"custom-block warning"},[v("p",{staticClass:"custom-block-title"},[t._v("注意")]),t._v(" "),v("p",[t._v("CPU中的PC寄存器在启动后会按照地址去取出第一条指令，然后开始执行程序。那么这个地址是什么？第一条指令要从哪个地址中取出？这些都是不一定的，需要软件和硬件在最开始就商量好")])]),t._v(" "),v("h3",{attrs:{id:"指令的发展"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#指令的发展"}},[t._v("#")]),t._v(" 指令的发展")]),t._v(" "),v("p",[t._v("最开始，人类使用由0和1构成的机器码来操作计算机，他们把这些机器码通过在纸带上打孔的方式表示，并送入计算机中执行。随着技术进步，人们开始使用汇编语言编写程序，通过工具把汇编语言转换成机器码来执行。之后又诞生了高级语言，这些高级语言可以通过一些复杂的工具转化成一条条汇编语言指令，这些指令再通过工具转换成0和1构成的机器码，从而操作计算机")]),t._v(" "),v("h3",{attrs:{id:"x86体系结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#x86体系结构"}},[t._v("#")]),t._v(" X86体系结构")]),t._v(" "),v("p",[t._v("X86架构是一种计算机指令集（指令系统），使用这种架构的微处理器有很多，以"),v("strong",[t._v("Intel 8086")]),t._v("为例：")]),t._v(" "),v("ul",[v("li",[t._v("这是一款"),v("strong",[t._v("16位的CPU")]),t._v("，运算部件支持"),v("strong",[t._v("16")]),t._v("位数据的运算。运算时所需要的数据一般存放在"),v("strong",[t._v("通用寄存器")]),t._v("中，由于"),v("strong",[t._v("通用寄存器")]),t._v("位宽一般和运算单元的位宽相同，所以它的内部通用寄存器为"),v("strong",[t._v("16")]),t._v("位")]),t._v(" "),v("li",[t._v("地址总线位宽为"),v("strong",[t._v("20位")]),t._v("（有20根地址线），可寻址的内存空间为"),v("mjx-container",{staticClass:"MathJax",staticStyle:{direction:"ltr",position:"relative"},attrs:{jax:"SVG"}},[v("svg",{staticStyle:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"0"},attrs:{xmlns:"http://www.w3.org/2000/svg",width:"2.919ex",height:"1.887ex",role:"img",focusable:"false",viewBox:"0 -833.9 1290.1 833.9","aria-hidden":"true"}},[v("g",{attrs:{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"scale(1,-1)"}},[v("g",{attrs:{"data-mml-node":"math"}},[v("g",{attrs:{"data-mml-node":"msup"}},[v("g",{attrs:{"data-mml-node":"mn"}},[v("path",{staticStyle:{"stroke-width":"3"},attrs:{"data-c":"32",d:"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"}})]),v("g",{attrs:{"data-mml-node":"TeXAtom",transform:"translate(533,363) scale(0.707)","data-mjx-texclass":"ORD"}},[v("g",{attrs:{"data-mml-node":"mn"}},[v("path",{staticStyle:{"stroke-width":"3"},attrs:{"data-c":"32",d:"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"}}),v("path",{staticStyle:{"stroke-width":"3"},attrs:{"data-c":"30",d:"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z",transform:"translate(500,0)"}})])])])])])]),v("mjx-assistive-mml",{staticStyle:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"},attrs:{unselectable:"on",display:"inline"}},[v("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[v("msup",[v("mn",[t._v("2")]),v("mrow",{attrs:{"data-mjx-texclass":"ORD"}},[v("mn",[t._v("20")])],1)],1)],1)],1)],1),v("strong",[t._v("Byte")]),t._v("=1"),v("strong",[t._v("MB")]),t._v("，1M可以表示"),v("strong",[t._v("0x100000")]),t._v("个地址，所以寻址范围为"),v("strong",[t._v("00000-FFFFF")]),t._v("（这里用十六进制表示）")],1),t._v(" "),v("li",[t._v("数据总线位宽为16位（有16根数据线）")])]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),v("p",[t._v("CPU的取址能力取决于地址总线能够传输多少种数据")])]),t._v(" "),v("p",[v("img",{attrs:{src:"/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/X86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.svg",alt:"X86体系结构"}})]),t._v(" "),v("p",[t._v("在"),v("strong",[t._v("Intel 8086")]),t._v("之后，英特尔又推出了"),v("strong",[t._v("Intel 80386")]),t._v("，这是X86系列中第一款32位的处理器，支持32位的运算和32位的通用寄存器，地址总线也扩展到了32位，所以可以寻址"),v("mjx-container",{staticClass:"MathJax",staticStyle:{direction:"ltr",position:"relative"},attrs:{jax:"SVG"}},[v("svg",{staticStyle:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"0"},attrs:{xmlns:"http://www.w3.org/2000/svg",width:"2.919ex",height:"1.887ex",role:"img",focusable:"false",viewBox:"0 -833.9 1290.1 833.9","aria-hidden":"true"}},[v("g",{attrs:{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"scale(1,-1)"}},[v("g",{attrs:{"data-mml-node":"math"}},[v("g",{attrs:{"data-mml-node":"msup"}},[v("g",{attrs:{"data-mml-node":"mn"}},[v("path",{staticStyle:{"stroke-width":"3"},attrs:{"data-c":"32",d:"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"}})]),v("g",{attrs:{"data-mml-node":"TeXAtom",transform:"translate(533,363) scale(0.707)","data-mjx-texclass":"ORD"}},[v("g",{attrs:{"data-mml-node":"mn"}},[v("path",{staticStyle:{"stroke-width":"3"},attrs:{"data-c":"33",d:"M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"}}),v("path",{staticStyle:{"stroke-width":"3"},attrs:{"data-c":"32",d:"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z",transform:"translate(500,0)"}})])])])])])]),v("mjx-assistive-mml",{staticStyle:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"},attrs:{unselectable:"on",display:"inline"}},[v("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[v("msup",[v("mn",[t._v("2")]),v("mrow",{attrs:{"data-mjx-texclass":"ORD"}},[v("mn",[t._v("32")])],1)],1)],1)],1)],1),v("strong",[t._v("=4GB")]),t._v("的内存空间。")],1),t._v(" "),v("ul",[v("li",[v("strong",[t._v("32位")]),t._v("的"),v("strong",[t._v("X86体系结构")]),t._v("被称为"),v("strong",[t._v("IA-32")])]),t._v(" "),v("li",[t._v("在指令中使用"),v("strong",[t._v("64位")]),t._v("寄存器时可以用"),v("strong",[t._v("RAX")]),t._v("，如果要使用"),v("strong",[t._v("32位")]),t._v("寄存器时用"),v("strong",[t._v("EAX")]),t._v("，也可用"),v("strong",[t._v("AX")]),t._v("来使用"),v("strong",[t._v("16位")]),t._v("的寄存器，或者用"),v("strong",[t._v("AH")]),t._v("或"),v("strong",[t._v("AL")]),t._v("来使用"),v("strong",[t._v("8位")]),t._v("的寄存器")])]),t._v(" "),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("各寄存器部件说明")]),t._v(" "),v("p",[v("strong",[t._v("AX（Accumulator）（AH、AL）累加器")]),t._v("，它是汇编编程中最常用的一个寄存器，主要用于乘除运算、BCD运算、换码、I/O操作、串操作和中断调用等。")]),t._v(" "),v("p",[v("strong",[t._v("BX（Base）（BH、BL）基址寄存器")]),t._v("，主要用于存放地址和基址（默认相对于DS段）等。")]),t._v(" "),v("p",[v("strong",[t._v("CX（Counter）（CH、CL）计数器")]),t._v("，主要用于循环计数、串操作计数和移位计数（CL）等。")]),t._v(" "),v("p",[v("strong",[t._v("DX（Data）（DH、DL）数据寄存器")]),t._v("，主要用于16位乘除、间接I/O和中断调用等。")]),t._v(" "),v("p",[v("strong",[t._v("BP（Base Pointer）基址指针")]),t._v("，主要用于存放地址和基址（默认相对于SS段）等。")]),t._v(" "),v("p",[v("strong",[t._v("SP（Stack Pointer）堆栈指针（栈顶指针）")]),t._v("，主要用于存放栈顶地址。")]),t._v(" "),v("p",[v("strong",[t._v("SI（Source Index）源变址寄存器")]),t._v("，用于存放地址、变址和串操作源变址。")]),t._v(" "),v("p",[v("strong",[t._v("DI（Destination Index）目的变址寄存器")]),t._v("，用于存放地址、变址和串操作目的变址。")]),t._v(" "),v("p",[v("strong",[t._v("CS（CodeSegment）代码段寄存器（代码段）")]),t._v("，用于存放正在或正待执行的程序段的起始地址的高16位二进制数据，即程序段的段地址。")]),t._v(" "),v("p",[v("strong",[t._v("DS（Data Segment）数据段寄存器（数据段）")]),t._v("，用于存放正在或正待处理的一般数据段的起始地址的高16位二进制数据，即一般数据段的段地址。")]),t._v(" "),v("p",[v("strong",[t._v("ES（Extra Segment）附加数据段寄存器（附加段）")]),t._v("，用于存放正在或正待处理的附加数据段的起始地址的高16位二进制数据，即附加数据段的段地址。")]),t._v(" "),v("p",[v("strong",[t._v("SS（Stack Segment）堆栈数据段寄存器（堆栈段）")]),t._v("，用于存放正在或正待处理的堆栈数据段的起始地址的高16位二进制数据，即堆栈数据段的段地址。")])]),t._v(" "),v("h4",{attrs:{id:"标志寄存器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#标志寄存器"}},[t._v("#")]),t._v(" 标志寄存器")]),t._v(" "),v("p",[v("strong",[t._v("FLAGS寄存器")]),t._v("中包含若干标志位标志位分为两大类："),v("strong",[t._v("状态标志")]),t._v("和"),v("strong",[t._v("控制标志")])]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("状态标志反映CPU的工作状态")]),t._v("，例如：执行加法运算时是否产生进位，运算结果是否为零")]),t._v(" "),v("li",[v("strong",[t._v("控制标志对CPU的运行起特定控制作用")]),t._v("，例如：以单步方式还是连续方式运行，是否允许响应外部中断请求")]),t._v(" "),v("li",[v("strong",[t._v("Intel 8086")]),t._v("的标志寄存器有"),v("strong",[t._v("16位")]),t._v("，在标志位中存储0或1表达该标志位的状态")])]),t._v(" "),v("p",[v("img",{attrs:{src:"/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8.svg",alt:"标志寄存器"}})]),t._v(" "),v("details",{staticClass:"custom-block details"},[v("summary",[t._v("标志寄存器中各标志位说明")]),t._v(" "),v("p",[v("strong",[t._v("IF（Interrupt enable Flag）中断允许标志")]),t._v("，用于控制CPU能否响应可屏蔽中断请求， IF=1能够响应，IF=0不能响应。")]),t._v(" "),v("p",[v("strong",[t._v("DF（Direction Flag）方向标志")]),t._v("，用于指示串操作时源串的源变址和目的串的目的变址的变化方向，DF=1向减的方向变化，DF=0向加的方向变化。")]),t._v(" "),v("p",[v("strong",[t._v("TF（Trap Flag）陷阱标志（单步中断标志）")]),t._v("，TF=1程序执行当前指令后暂停，TF=0程序执行当前指令后不会暂停。")]),t._v(" "),v("p",[v("strong",[t._v("SF（Sign Flag）符号标志")]),t._v("，指令执行结果的最高二进制位是0还是1，为0，则SF=0，代表正数；为1，则SF=1，代表负数。我们一般是用十六进制数表示，则可以看十六进制的最高位是落在0~7还是落在8~F之间，若落在0~7之间则SF=0，否则SF=1。")]),t._v(" "),v("p",[v("strong",[t._v("PF（Parity check Flag）奇偶校验标志")]),t._v("，指令执行结果的低8位中1的个数是奇数个还是偶数个，若为奇数个则PF=0，若为偶数个则PF=1。")]),t._v(" "),v("p",[v("strong",[t._v("ZF（Zero Flag）零标志")]),t._v("，指令执行结果是不是为0，若为0则ZF=1，否则ZF=0。")]),t._v(" "),v("p",[v("strong",[t._v("OF（Overflow Flag）有符号数的溢出标志")]),t._v("，指令执行结果是否超出有符号数的表示范围，若超过则OF=1，否则OF=0.我们可以通过是否出现以下四种情况之一来判断：正加正得负，正减负得负，负加负得正，负减正得正。若出现则OF=1，否则OF=0。")]),t._v(" "),v("p",[v("strong",[t._v("CF（Carry Flag）进位/借位标志（无符号数的溢出标志）")]),t._v("，指令执行结果的最高位是否有向更高位进位或借位，若有则CF=1，同时也代表无符号数溢出；若无则CF=0，也代表无符号数未溢出。")]),t._v(" "),v("p",[v("strong",[t._v("AF（Auxiliary carry Flag）辅助进位/借位标志")]),t._v("，低4位二进制是不是有向高位进位或借位，若有则AF=1，否则AF=0，其主要用于BCD修正运算。")])]),t._v(" "),v("h4",{attrs:{id:"指令指针寄存器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#指令指针寄存器"}},[t._v("#")]),t._v(" 指令指针寄存器")]),t._v(" "),v("p",[v("strong",[t._v("IP（Instruction Pointer）指令指针寄存器")]),t._v("，与"),v("RouterLink",{attrs:{to:"/computer/计算机组成原理.html#计算机执行指令的过程"}},[t._v("PC寄存器")]),t._v("的作用相同。在"),v("strong",[t._v("Intel 8086")]),t._v("中叫做IP寄存器")],1),t._v(" "),v("ul",[v("li",[t._v("保存"),v("strong",[t._v("一个")]),t._v("内存地址，且该地址指向当前需要取出的指令")]),t._v(" "),v("li",[t._v("当CPU从内存中取出一个指令后，IP寄存器地址会"),v("strong",[t._v("自动递增")]),t._v("，指向下一指令的地址")]),t._v(" "),v("li",[t._v("无法通过编写的程序直接修改IP寄存器，但转移指令、过程调用/返回指令等指令会改变IP寄存器中的地址")]),t._v(" "),v("li",[v("strong",[t._v("Intel 8086")]),t._v("的"),v("strong",[t._v("IP寄存器")]),t._v("位宽为"),v("strong",[t._v("16位")]),t._v("所以他的寻址能力为"),v("mjx-container",{staticClass:"MathJax",staticStyle:{direction:"ltr",position:"relative"},attrs:{jax:"SVG"}},[v("svg",{staticStyle:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"0"},attrs:{xmlns:"http://www.w3.org/2000/svg",width:"2.919ex",height:"1.887ex",role:"img",focusable:"false",viewBox:"0 -833.9 1290.1 833.9","aria-hidden":"true"}},[v("g",{attrs:{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"scale(1,-1)"}},[v("g",{attrs:{"data-mml-node":"math"}},[v("g",{attrs:{"data-mml-node":"msup"}},[v("g",{attrs:{"data-mml-node":"mn"}},[v("path",{staticStyle:{"stroke-width":"3"},attrs:{"data-c":"32",d:"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"}})]),v("g",{attrs:{"data-mml-node":"TeXAtom",transform:"translate(533,363) scale(0.707)","data-mjx-texclass":"ORD"}},[v("g",{attrs:{"data-mml-node":"mn"}},[v("path",{staticStyle:{"stroke-width":"3"},attrs:{"data-c":"31",d:"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"}}),v("path",{staticStyle:{"stroke-width":"3"},attrs:{"data-c":"36",d:"M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z",transform:"translate(500,0)"}})])])])])])]),v("mjx-assistive-mml",{staticStyle:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"},attrs:{unselectable:"on",display:"inline"}},[v("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[v("msup",[v("mn",[t._v("2")]),v("mrow",{attrs:{"data-mjx-texclass":"ORD"}},[v("mn",[t._v("16")])],1)],1)],1)],1)],1),v("strong",[t._v("=65536B=64KB")]),t._v("，由于64kb实在太小，无法满足大部分程序的需求，所以8086采用了与四个段寄存器联合的方式生成存储器地址，将寻址能力达到了"),v("mjx-container",{staticClass:"MathJax",staticStyle:{direction:"ltr",position:"relative"},attrs:{jax:"SVG"}},[v("svg",{staticStyle:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"0"},attrs:{xmlns:"http://www.w3.org/2000/svg",width:"2.919ex",height:"1.887ex",role:"img",focusable:"false",viewBox:"0 -833.9 1290.1 833.9","aria-hidden":"true"}},[v("g",{attrs:{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"scale(1,-1)"}},[v("g",{attrs:{"data-mml-node":"math"}},[v("g",{attrs:{"data-mml-node":"msup"}},[v("g",{attrs:{"data-mml-node":"mn"}},[v("path",{staticStyle:{"stroke-width":"3"},attrs:{"data-c":"32",d:"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"}})]),v("g",{attrs:{"data-mml-node":"TeXAtom",transform:"translate(533,363) scale(0.707)","data-mjx-texclass":"ORD"}},[v("g",{attrs:{"data-mml-node":"mn"}},[v("path",{staticStyle:{"stroke-width":"3"},attrs:{"data-c":"32",d:"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"}}),v("path",{staticStyle:{"stroke-width":"3"},attrs:{"data-c":"30",d:"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z",transform:"translate(500,0)"}})])])])])])]),v("mjx-assistive-mml",{staticStyle:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"},attrs:{unselectable:"on",display:"inline"}},[v("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[v("msup",[v("mn",[t._v("2")]),v("mrow",{attrs:{"data-mjx-texclass":"ORD"}},[v("mn",[t._v("20")])],1)],1)],1)],1)],1),v("strong",[t._v("=1MB")])],1)]),t._v(" "),v("h4",{attrs:{id:"段寄存器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#段寄存器"}},[t._v("#")]),t._v(" 段寄存器")]),t._v(" "),v("p",[v("strong",[t._v("Intel 8086中有四个段寄存器：")])]),t._v(" "),v("ul",[v("li",[t._v("CS（Code Segment）代码段寄存器")]),t._v(" "),v("li",[t._v("DS（Data Segment）数据段寄存器")]),t._v(" "),v("li",[t._v("ES（Extra Segment）附加段寄存器")]),t._v(" "),v("li",[t._v("SS（Stack Segment）堆栈段寄存器")])]),t._v(" "),v("p",[v("strong",[t._v("以代码段寄存器为例，演示8086微处理器物理地址生成的过程")])]),t._v(" "),v("p",[v("img",{attrs:{src:"/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8086%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B.svg",alt:"标志寄存器"}})]),t._v(" "),v("p",[t._v("在"),v("strong",[t._v("代码段寄存器")]),t._v("中现在存放着一个"),v("strong",[t._v("16位")]),t._v("的值，用"),v("strong",[t._v("十六进制")]),t._v("表示为0X"),v("strong",[t._v("2000")]),t._v("，根据程序运行的状况，当前"),v("strong",[t._v("IP寄存器")]),t._v("中的值为0X"),v("strong",[t._v("3000")]),t._v("。然后通过"),v("strong",[t._v("移位器")]),t._v("对"),v("strong",[t._v("代码段寄存器")]),t._v("中的值进行"),v("strong",[t._v("移位")]),t._v("，（"),v("strong",[t._v("在8086中采用的是20位的物理地址，代码段寄存器地址为16位所以要向将该地址向左移4位")]),t._v("）移位后新产生的值为0X"),v("strong",[t._v("20000")]),t._v("，然后将这个值与"),v("strong",[t._v("IP寄存器")]),t._v("中的值"),v("strong",[t._v("相加")]),t._v("，得到一个"),v("strong",[t._v("20位")]),t._v("的"),v("strong",[t._v("物理地址")]),t._v("，这时CPU就会将这个地址发送到存储器中取出下一条指令并执行。"),v("strong",[t._v("这也是地址总线位宽设计为20位的原因")])]),t._v(" "),v("ul",[v("li",[t._v("X86体系结构中的指令长度不是固定的，它可以根据需要设定指令的长度(多少字节)")]),t._v(" "),v("li",[t._v("丰富的指令让编写程序变得容易，但让CPU的设计变得非常复杂")])]),t._v(" "),v("h3",{attrs:{id:"x86指令简介"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#x86指令简介"}},[t._v("#")]),t._v(" X86指令简介")]),t._v(" "),v("p",[t._v("通常一个指令系统主要包括这几类指令：")]),t._v(" "),v("p",[v("strong",[t._v("运算类指令")]),t._v("：例如"),v("strong",[t._v("加，减，乘，除")]),t._v("这种"),v("strong",[t._v("算数运算")]),t._v("或者"),v("strong",[t._v("或，与，非")]),t._v("这类"),v("strong",[t._v("逻辑运算")])]),t._v(" "),v("p",[v("strong",[t._v("传送类指令")]),t._v("：例如把"),v("strong",[t._v("数据")]),t._v("从"),v("strong",[t._v("存储器")]),t._v("送到"),v("strong",[t._v("通用寄存器")]),t._v("中或者从"),v("strong",[t._v("通用寄存器")]),t._v("送到"),v("strong",[t._v("输入输出接口")])]),t._v(" "),v("blockquote",[v("p",[v("strong",[t._v("有了这两类指令计算机就可以从外界获取数据，并在计算机中进行运算，然后将结果输出到外界，如果要编写像高级语言中"),v("code",[t._v("if")]),t._v(","),v("code",[t._v("while")]),t._v(","),v("code",[t._v("for")]),t._v("这样复杂点的程序就需要用到转移类指令")])])]),t._v(" "),v("p",[v("strong",[t._v("转移类指令")]),t._v("：例如无条件转移，条件转移，过程调用等")]),t._v(" "),v("p",[v("strong",[t._v("控制类指令")]),t._v("："),v("strong",[t._v("对CPU进行控制的指令")]),t._v("，例如暂停处理器，清除标志位等")]),t._v(" "),v("p",[t._v("现在，通过以下任务示例简单介绍X86体系结构中各类指令在计算机中如何工作（只演示X86体系结构中众多指令的部分指令）")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("任务")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("在存储器中")]),t._v("，把在起始地址为"),v("strong",[t._v("2000H")]),t._v("的数和起始地址为"),v("strong",[t._v("3000H")]),t._v("的数相加。")]),t._v(" "),v("li",[v("strong",[t._v("两数的长度")]),t._v("存放在地址为"),v("strong",[t._v("2500H")]),t._v("的存储单元中")])]),t._v(" "),v("p",[t._v("注：结尾带"),v("strong",[t._v("H")]),t._v("的数表示该数为"),v("strong",[t._v("十六进制")])])]),t._v(" "),v("p",[v("img",{attrs:{src:"/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/X86%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B.svg",alt:"X86指令简介"}})]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("MOV CL，[2500H]")]),t._v(" 将地址为2500H的内存单元中的内容传入CL寄存器")])]),t._v(" "),v("blockquote",[v("p",[t._v("这个内存单元保存运算数的长度")])]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("MOV SI， 2000H")]),t._v(" 将2000H这个数传送到SI寄存器中")])]),t._v(" "),v("blockquote",[v("p",[t._v("将第一个运算数的起始地址保存在SI寄存器")])]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("MOV DI， 3000H")]),t._v(" 将3000H这个数传送到DI寄存器中")])]),t._v(" "),v("blockquote",[v("p",[t._v("将第二个运算数的起始地址保存在DI寄存器")])]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("CLC")]),t._v(" 将CF标志位清零")])]),t._v(" "),v("blockquote",[v("p",[t._v("下面的ADC指令在进行加法运算时还会加上进位，但第一次两数相加时不应该进位，所以这里要将CF标志位清零")])]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("MOV AX，[SI]")]),t._v(" 将地址为2000H的存储单元中的第一个字（前两个字节）传送到AX寄存器当中")]),t._v(" "),v("li",[v("strong",[t._v("ADC AX，[DI]")]),t._v(" 将地址为3000H的存储单元中的第一个字与AX寄存器当中的数相加，并把结果存到AX寄存器中")])]),t._v(" "),v("blockquote",[v("p",[t._v("这里之所以要使用ADC指令而不是ADD指令是因为ADC指令在运算时会加上CF标志位，两数相加可能会产生进位，ADC指令会让进位传递到下一次运算，以保证运算结果正确无误")])]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("MOV [SI]， AX")]),t._v("将AX寄存器中的内容传送到SI所指向的内存单元")]),t._v(" "),v("li",[v("strong",[t._v("INC SI")]),t._v(" 递增SI寄存器中的数")]),t._v(" "),v("li",[v("strong",[t._v("INC DI")]),t._v(" 递增DI寄存器中的数")])]),t._v(" "),v("blockquote",[v("p",[v("strong",[t._v("SI")]),t._v("和"),v("strong",[t._v("DI寄存器")]),t._v("之所以要递增两次是因为之前两数的第一个字（前两个字节）已经相加，下一次进行循环累加时应该加第二个字,由于一个字占两个字节，所以在"),v("strong",[t._v("SI寄存器")]),t._v("和"),v("strong",[t._v("DI寄存器")]),t._v("中的内存地址要往后移"),v("strong",[t._v("两位")])])]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("DEC CL")]),t._v(" 将CL寄存器中的内容减一")])]),t._v(" "),v("blockquote",[v("p",[t._v("每运算一次CL寄存器中保存的运算数长度就减一，当运算数长度减为0时怎表示运算数的没一位都完成了运算，这时再执行下一条指令"),v("strong",[t._v("JNZ LOOP1")]),t._v("时条件则不满足，循环累加的操作就会停止")])]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("JNZ LOOP1")]),t._v(" 如果前一条指令运算结果不为0则转移到LOOP1所指定位置开始执行，如果为0则跳过该指令，继续下一条指令")])]),t._v(" "),v("h4",{attrs:{id:"传送类指令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#传送类指令"}},[t._v("#")]),t._v(" 传送类指令")]),t._v(" "),v("p",[t._v("作用：把数据和地址传送到寄存器或存储器单元中")]),t._v(" "),v("p",[v("strong",[t._v("MOV指令")])]),t._v(" "),v("ul",[v("li",[t._v("格式："),v("strong",[t._v("MOV DST, SRC")]),t._v(" （DST表示目的位置,SRC表示源位置或源操作数）")]),t._v(" "),v("li",[t._v("作用：把一个操作数从源位置传送到目的位置，源操作数的内容不变")])]),t._v(" "),v("p",[t._v("这条指令的格式有丰富的变化，例如：")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("指令示例")]),t._v(" "),v("th",[t._v("说明")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[v("strong",[t._v("MOV EBX, 40")])]),t._v(" "),v("td",[t._v("将40这个数送到EBX寄存器当中（直接给出操作数）")])]),t._v(" "),v("tr",[v("td",[v("strong",[t._v("MOV AL, BL")])]),t._v(" "),v("td",[t._v("将BL寄存器中的内容传送到AL寄存器中（给出寄存器名称）")])]),t._v(" "),v("tr",[v("td",[v("strong",[t._v("MOV ECX, [1000H]")])]),t._v(" "),v("td",[t._v("将地址1000H的存储器单元的内容取出，传送到ECX寄存器中（给出存储器地址）")])]),t._v(" "),v("tr",[v("td",[v("strong",[t._v("MOV [DI], AX")])]),t._v(" "),v("td",[t._v('将AX寄存器中的内容传送到存储器的某个单元，这个单元的地址存放在DI寄存器中（给出存放"存放操作数的存储器地址"的寄存器名称）')])]),t._v(" "),v("tr",[v("td",[v("strong",[t._v("MOV WORD PTR[BX+SI*2+200H], 01H")])]),t._v(" "),v("td",[t._v("把01H这个数存放在某个内存单元中，这个内存单元的地址要通过计算获得。计算过程：从SI寄存器中取出数并乘2，再从BX寄存器中取出数，二者相加，之后再加上200H")])])])]),t._v(" "),v("h4",{attrs:{id:"运算类指令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#运算类指令"}},[t._v("#")]),t._v(" 运算类指令")]),t._v(" "),v("p",[t._v("计算机能够执行的基本数值计算，包括加法"),v("strong",[t._v("ADD")]),t._v("、减法"),v("strong",[t._v("SUB")]),t._v("、乘法"),v("strong",[t._v("MUL")]),t._v("、除法"),v("strong",[t._v("DIV")]),t._v("等")]),t._v(" "),v("p",[v("strong",[t._v("ADD指令")])]),t._v(" "),v("ul",[v("li",[t._v("格式："),v("strong",[t._v("ADD DST, SRC")])]),t._v(" "),v("li",[t._v("操作：将两个操作数相加并将结果存放在存放第一个操作数的内存单元中（DST←DST+SRC）")])]),t._v(" "),v("p",[v("strong",[t._v("INC指令")])]),t._v(" "),v("ul",[v("li",[t._v("格式："),v("strong",[t._v("INC OPR")])]),t._v(" "),v("li",[t._v("操作：将操作数+1（OPR←OPR+1）")])]),t._v(" "),v("p",[v("strong",[t._v("DEC指令")])]),t._v(" "),v("ul",[v("li",[t._v("格式："),v("strong",[t._v("DEC OPR")])]),t._v(" "),v("li",[t._v("操作：将操作数-1（OPR←OPR-1）")])]),t._v(" "),v("p",[v("strong",[t._v("ADC指令")])]),t._v(" "),v("ul",[v("li",[t._v("格式："),v("strong",[t._v("ADC DST, SRC")]),t._v(" （带进位的加）")]),t._v(" "),v("li",[t._v("操作：将两个操作数相加，再加上CF标志位（DST←DST+SRC+CF）")])]),t._v(" "),v("blockquote",[v("p",[t._v("注：如果运算器做两数相加的运算时产生了"),v("strong",[t._v("进位")]),t._v("，计算机就会改写标志寄存器中的"),v("strong",[t._v("CF标志位")]),t._v("，当下一次运算时使用了"),v("strong",[t._v("ADC指令")]),t._v("，"),v("strong",[t._v("CF标志位")]),t._v("也会参与运算，这样前一次运算的结果就会影响后一次运算。"),v("strong",[t._v("ADC指令")]),t._v("的进位也会影响"),v("strong",[t._v("CF标志")]),t._v("位，"),v("strong",[t._v("ADD")]),t._v("和"),v("strong",[t._v("ADC")]),t._v("指令都会根据结果影响"),v("strong",[t._v("CF标志位")])])]),t._v(" "),v("h4",{attrs:{id:"转移类指令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#转移类指令"}},[t._v("#")]),t._v(" 转移类指令")]),t._v(" "),v("p",[t._v("用于改变指令执行的顺序")]),t._v(" "),v("p",[v("strong",[t._v("JNZ指令")])]),t._v(" "),v("p",[t._v("这是一条"),v("strong",[t._v("条件转移指令")]),t._v("，根据条件执行")]),t._v(" "),v("ul",[v("li",[t._v("格式： "),v("strong",[t._v("JNZ LOOP")])]),t._v(" "),v("li",[t._v("操作：检查前一条指令的运算结果是否为0，如果不为0或不相等时则转移到LOOP所指的位置")])]),t._v(" "),v("p",[t._v("实际上是检查标志寄存器中的ZF标志位，如果运算结果为0,ZF标志位就会被设置为1，表示这次的运算结果为0，否则ZF标志位为0")]),t._v(" "),v("h4",{attrs:{id:"控制类指令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#控制类指令"}},[t._v("#")]),t._v(" 控制类指令")]),t._v(" "),v("p",[t._v("作用：控制CPU的功能，对标志位进行操作")]),t._v(" "),v("p",[v("strong",[t._v("CLC指令")])]),t._v(" "),v("ul",[v("li",[t._v("格式："),v("strong",[t._v("CLC")])]),t._v(" "),v("li",[t._v("作用：把进位标志位(CF)清零")])]),t._v(" "),v("h3",{attrs:{id:"mips体系结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mips体系结构"}},[t._v("#")]),t._v(" MIPS体系结构")]),t._v(" "),v("p",[v("strong",[t._v("MIPS")]),t._v("架构是由斯坦福大学开发的一种"),v("strong",[t._v("RISC")]),t._v("架构，")])])}),[],!1,null,null,null);v.default=r.exports}}]);